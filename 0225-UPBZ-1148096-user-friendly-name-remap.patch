---
 libmultipath/alias.c       |   81 ++++++++++++++++++++++++++++++++++++---------
 libmultipath/alias.h       |    2 +
 libmultipath/propsel.c     |   27 ++++++++++-----
 libmultipath/structs_vec.c |   16 ++++++++
 4 files changed, 102 insertions(+), 24 deletions(-)

Index: multipath-tools/libmultipath/alias.c
===================================================================
--- multipath-tools.orig/libmultipath/alias.c
+++ multipath-tools/libmultipath/alias.c
@@ -139,13 +139,11 @@ rlookup_binding(FILE *f, char **map_wwid
 {
 	char buf[LINE_MAX];
 	unsigned int line_nr = 0;
-	int id = 0;
 
 	*map_wwid = NULL;
 
 	while (fgets(buf, LINE_MAX, f)) {
 		char *c, *alias, *wwid;
-		int curr_id;
 
 		line_nr++;
 		c = strpbrk(buf, "#\n\r");
@@ -154,9 +152,6 @@ rlookup_binding(FILE *f, char **map_wwid
 		alias = strtok(buf, " \t");
 		if (!alias) /* blank line */
 			continue;
-		curr_id = scan_devname(alias);
-		if (curr_id >= id)
-			id = curr_id + 1;
 		wwid = strtok(NULL, "");
 		if (!wwid){
 			condlog(3,
@@ -171,11 +166,12 @@ rlookup_binding(FILE *f, char **map_wwid
 			if (*map_wwid == NULL)
 				condlog(0, "Cannot copy alias from bindings "
 					"file : %s", strerror(errno));
-			return id;
+			return 0;
 		}
 	}
 	condlog(3, "No matching alias [%s] in bindings file.", map_alias);
-	return id;
+
+	return -1;
 }
 
 static char *
@@ -223,6 +219,67 @@ allocate_binding(int fd, char *wwid, int
 }
 
 char *
+use_existing_alias (char *wwid, char *file, char *alias_old,
+		    int bindings_read_only)
+{
+	char *alias = NULL;
+	int id = 0;
+	int fd, can_write;
+	char *buff;
+	FILE *f;
+
+	fd = open_file(file, &can_write, BINDINGS_FILE_HEADER);
+	if (fd < 0)
+		return NULL;
+
+	f = fdopen(fd, "r");
+	if (!f) {
+		condlog(0, "cannot fdopen on bindings file descriptor");
+		close(fd);
+		return NULL;
+	}
+	/* lookup the binding. if it exsists, the wwid will be in buff */
+	rlookup_binding(f, &buff, alias_old);
+
+	if (buff != NULL) {
+		/* if buff is our wwid, it's already
+		 * allocated correctly
+		 */
+		if (strcmp(buff, wwid) == 0) {
+			alias = strdup(alias_old);
+			if (alias == NULL)
+				condlog(0, "cannot copy alias : %s",
+					strerror(errno));
+		} else {
+			alias = NULL;
+			condlog(0, "alias %s already bound to wwid %s, cannot reuse", alias_old, buff);
+		}
+		free(buff);
+		goto out;
+	}
+
+	/* allocate the existing alias in the bindings file */
+	id = scan_devname(alias_old);
+	if (id <= 0)
+		goto out;
+
+	if (fflush(f) != 0) {
+		condlog(0, "cannot fflush bindings file stream : %s",
+			strerror(errno));
+		goto out;
+	}
+
+	if (can_write && !bindings_read_only) {
+		alias = allocate_binding(fd, wwid, id);
+		condlog(0, "Allocated existing binding [%s] for WWID [%s]",
+			alias, wwid);
+	}
+out:
+	fclose(f);
+	return alias;
+}
+
+char *
 get_user_friendly_alias(char *wwid, char *file, int bindings_read_only)
 {
 	char *alias;
@@ -280,7 +337,7 @@ char *
 get_user_friendly_wwid(char *alias, char *file)
 {
 	char *wwid;
-	int fd, scan_fd, id, unused;
+	int fd, scan_fd, unused;
 	FILE *f;
 
 	if (!alias || *alias == '\0') {
@@ -312,13 +369,7 @@ get_user_friendly_wwid(char *alias, char
 		return NULL;
 	}
 
-	id = rlookup_binding(f, &wwid, alias);
-	if (id < 0) {
-		fclose(f);
-		close(scan_fd);
-		close(fd);
-		return NULL;
-	}
+	rlookup_binding(f, &wwid, alias);
 
 	fclose(f);
 	close(scan_fd);
Index: multipath-tools/libmultipath/alias.h
===================================================================
--- multipath-tools.orig/libmultipath/alias.h
+++ multipath-tools/libmultipath/alias.h
@@ -9,3 +9,5 @@
 
 char *get_user_friendly_alias(char *wwid, char *file, int bindings_readonly);
 char *get_user_friendly_wwid(char *alias, char *file);
+char *use_existing_alias (char *wwid, char *file, char *alias_old,
+			  int bindings_read_only);
Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -227,18 +227,27 @@ want_user_friendly_names(struct multipat
 extern int
 select_alias (struct multipath * mp)
 {
-	if (mp->mpe && mp->mpe->alias)
+	if (mp->mpe && mp->mpe->alias) {
 		mp->alias = mp->mpe->alias;
-	else {
-		mp->alias = NULL;
-		if (want_user_friendly_names(mp))
-			mp->alias = get_user_friendly_alias(mp->wwid,
-					conf->bindings_file,
-					conf->bindings_read_only);
-		if (mp->alias == NULL)
-			mp->alias = mp->wwid;
+		goto out;
+	}
+	mp->alias = NULL;
+	if (!want_user_friendly_names(mp))
+		goto out;
+
+	if (strlen(mp->alias_old) > 0) {
+		mp->alias = use_existing_alias(mp->wwid, conf->bindings_file,
+					       mp->alias_old,
+					       conf->bindings_read_only);
+		memset (mp->alias_old, 0, WWID_SIZE);
 	}
 
+	if (mp->alias == NULL)
+		mp->alias = get_user_friendly_alias(mp->wwid,
+				conf->bindings_file, conf->bindings_read_only);
+out:
+	if (mp->alias == NULL)
+		mp->alias = mp->wwid;
 	return 0;
 }
 
Index: multipath-tools/libmultipath/structs_vec.c
===================================================================
--- multipath-tools.orig/libmultipath/structs_vec.c
+++ multipath-tools/libmultipath/structs_vec.c
@@ -449,6 +449,21 @@ out:
 	return NULL;
 }
 
+static void
+find_existing_alias (struct multipath * mpp,
+		     struct vectors *vecs)
+{
+	struct multipath * mp;
+	int i;
+
+	vector_foreach_slot (vecs->mpvec, mp, i) {
+		if (strcmp(mp->wwid, mpp->wwid) == 0) {
+			strncpy(mpp->alias_old, mp->alias, WWID_SIZE);
+			return;
+		}
+	}
+}
+
 extern struct multipath *
 add_map_with_path (struct vectors * vecs,
 		   struct path * pp, int add_vec)
@@ -462,6 +477,7 @@ add_map_with_path (struct vectors * vecs
 	mpp->hwe = pp->hwe;
 
 	strcpy(mpp->wwid, pp->wwid);
+	find_existing_alias(mpp, vecs);
 	select_alias(mpp);
 	mpp->size = pp->size;
 
