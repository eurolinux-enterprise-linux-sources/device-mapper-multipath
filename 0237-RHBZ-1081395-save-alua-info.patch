---
 libmultipath/prio.c                   |   34 ++++++++++++++++++
 libmultipath/prio.h                   |    7 +++
 libmultipath/prioritizers/alua.c      |   62 +++++++++++++++++++++++++---------
 libmultipath/prioritizers/alua_rtpg.c |   22 +++++++++---
 libmultipath/prioritizers/alua_rtpg.h |    4 +-
 libmultipath/prioritizers/const.c     |    4 ++
 libmultipath/prioritizers/def_func.h  |   11 ++++++
 libmultipath/prioritizers/emc.c       |    4 ++
 libmultipath/prioritizers/hds.c       |    4 ++
 libmultipath/prioritizers/hp_sw.c     |    4 ++
 libmultipath/prioritizers/ontap.c     |    4 ++
 libmultipath/prioritizers/random.c    |    4 ++
 libmultipath/prioritizers/rdac.c      |    4 ++
 libmultipath/prioritizers/weighted.c  |    4 ++
 libmultipath/propsel.c                |    4 +-
 multipathd/main.c                     |    8 ++++
 16 files changed, 160 insertions(+), 24 deletions(-)

Index: multipath-tools/libmultipath/prio.c
===================================================================
--- multipath-tools.orig/libmultipath/prio.c
+++ multipath-tools/libmultipath/prio.c
@@ -102,9 +102,24 @@ struct prio * add_prio (char * name)
 	p->getprio = (int (*)(struct path *)) dlsym(p->handle, "getprio");
 	errstr = dlerror();
 	if (errstr != NULL)
-	condlog(0, "A dynamic linking error occurred: (%s)", errstr);
+		condlog(0, "A dynamic linking error occurred with getprio: (%s)", errstr);
 	if (!p->getprio)
 		goto out;
+
+	p->initprio = (int (*)(struct prio *)) dlsym(p->handle, "initprio");
+	errstr = dlerror();
+	if (errstr != NULL)
+		condlog(0, "A dynamic linking error occurred with initprio: (%s)", errstr);
+	if (!p->initprio)
+		goto out;
+
+	p->freeprio = (int (*)(struct prio *)) dlsym(p->handle, "freeprio");
+	errstr = dlerror();
+	if (errstr != NULL)
+		condlog(0, "A dynamic linking error occurred with freeprio: (%s)", errstr);
+	if (!p->freeprio)
+		goto out;
+
 	snprintf(p->name, PRIO_NAME_LEN, "%s", name);
 	list_add(&p->node, &prioritizers);
 	return p;
@@ -113,6 +128,13 @@ out:
 	return NULL;
 }
 
+int prio_init (struct prio * p)
+{
+	if (!p || !p->initprio)
+		return 1;
+	return p->initprio(p);
+}
+
 int prio_getprio (struct prio * p, struct path * pp)
 {
 	return p->getprio(pp);
@@ -133,8 +155,16 @@ void prio_get (struct prio * dst, char *
 	}
 
 	strncpy(dst->name, src->name, PRIO_NAME_LEN);
+	dst->initprio = src->initprio;
 	dst->getprio = src->getprio;
+	dst->freeprio = src->freeprio;
 	dst->handle = NULL;
+	dst->context = NULL;
+
+	if (dst->initprio(dst) != 0) {
+		memset(dst, 0x0, sizeof(struct prio));
+		return;
+	}
 
 	src->refcount++;
 }
@@ -147,6 +177,8 @@ void prio_put (struct prio * dst)
 		return;
 
 	src = prio_lookup(dst->name);
+	if (dst->freeprio)
+		dst->freeprio(dst);
 	memset(dst, 0x0, sizeof(struct prio));
 	free_prio(src);
 }
Index: multipath-tools/libmultipath/prio.h
===================================================================
--- multipath-tools.orig/libmultipath/prio.h
+++ multipath-tools/libmultipath/prio.h
@@ -42,8 +42,14 @@ struct prio {
 	void *handle;
 	int refcount;
 	struct list_head node;
+	void * context;
 	char name[PRIO_NAME_LEN];
+	int (*initprio)(struct prio * p);
+	/* You are allowed to call initprio multiple times without calling
+	 * freeprio. Doing so will reinitialize it (possibly skipping
+	 * allocations) */
 	int (*getprio)(struct path *);
+	int (*freeprio)(struct prio * p);
 };
 
 unsigned int get_prio_timeout(unsigned int default_timeout);
@@ -52,6 +58,7 @@ void cleanup_prio (void);
 struct prio * add_prio (char *);
 struct prio * prio_lookup (char *);
 int prio_getprio (struct prio *, struct path *);
+int prio_init (struct prio *);
 void prio_get (struct prio *, char *);
 void prio_put (struct prio *);
 int prio_selected (struct prio *);
Index: multipath-tools/libmultipath/prioritizers/alua.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/alua.c
+++ multipath-tools/libmultipath/prioritizers/alua.c
@@ -36,6 +36,12 @@ static const char * aas_string[] = {
 	[AAS_TRANSITIONING]	= "transitioning between states",
 };
 
+struct alua_context {
+	int tpg_support;
+	int tpg;
+	int buflen;
+};
+
 static const char *aas_print_string(int rc)
 {
 	rc &= 0x7f;
@@ -50,25 +56,26 @@ static const char *aas_print_string(int 
 }
 
 int
-get_alua_info(int fd)
+get_alua_info(int fd, struct alua_context *ct)
 {
 	int	rc;
-	int	tpg;
 	int	aas;
 
-	rc = get_target_port_group_support(fd);
-	if (rc < 0)
-		return -ALUA_PRIO_TPGS_FAILED;
-
-	if (rc == TPGS_NONE)
-		return -ALUA_PRIO_NOT_SUPPORTED;
-
-	tpg = get_target_port_group(fd);
-	if (tpg < 0)
-		return -ALUA_PRIO_RTPG_FAILED;
+	if (ct->tpg_support <= 0 || ct->tpg < 0) {
+		ct->tpg_support = get_target_port_group_support(fd);
+		if (ct->tpg_support < 0)
+			return -ALUA_PRIO_TPGS_FAILED;
+
+		if (ct->tpg_support == TPGS_NONE)
+			return -ALUA_PRIO_NOT_SUPPORTED;
+
+		ct->tpg = get_target_port_group(fd, &ct->buflen);
+		if (ct->tpg < 0)
+			return -ALUA_PRIO_RTPG_FAILED;
+	}
 
-	condlog(3, "reported target port group is %i", tpg);
-	rc = get_asymmetric_access_state(fd, tpg);
+	condlog(3, "reported target port group is %i", ct->tpg);
+	rc = get_asymmetric_access_state(fd, ct->tpg, &ct->buflen);
 	if (rc < 0)
 		return -ALUA_PRIO_GETAAS_FAILED;
 	aas = (rc & 0x0f);
@@ -87,7 +94,7 @@ int getprio (struct path * pp)
 	if (pp->fd < 0)
 		return -ALUA_PRIO_NO_INFORMATION;
 
-	rc = get_alua_info(pp->fd);
+	rc = get_alua_info(pp->fd, pp->prio.context);
 	if (rc >= 0) {
 		aas = (rc & 0x0f);
 		priopath = (rc & 0x80);
@@ -127,3 +134,28 @@ int getprio (struct path * pp)
 	}
 	return rc;
 }
+
+int initprio(struct prio *p)
+{
+	if (!p->context) {
+		struct alua_context *ct;
+
+		ct = malloc(sizeof(struct alua_context));
+		if (!ct)
+			return 1;
+		p->context = ct;
+	}
+	memset(p->context, 0, sizeof(struct alua_context));
+	return 0;
+}
+
+
+int freeprio(struct prio *p)
+{
+	if (p->context) {
+		free(p->context);
+		p->context = NULL;
+	}
+	return 0;
+}
+
Index: multipath-tools/libmultipath/prioritizers/alua_rtpg.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/alua_rtpg.c
+++ multipath-tools/libmultipath/prioritizers/alua_rtpg.c
@@ -171,7 +171,7 @@ get_target_port_group_support(int fd)
 }
 
 int
-get_target_port_group(int fd)
+get_target_port_group(int fd, int *buflen_ptr)
 {
 	unsigned char		*buf;
 	struct vpd83_data *	vpd83;
@@ -179,7 +179,12 @@ get_target_port_group(int fd)
 	int			rc;
 	int			buflen, scsi_buflen;
 
-	buflen = 128; /* Lets start from 128 */
+	if (!buflen_ptr || *buflen_ptr == 0) {
+		buflen = 128; /* Lets start from 128 */
+		if (buflen_ptr)
+			*buflen_ptr = 128;
+	} else
+		buflen = *buflen_ptr;
 	buf = (unsigned char *)malloc(buflen);
 	if (!buf) {
 		PRINT_DEBUG("malloc failed: could not allocate"
@@ -202,6 +207,8 @@ get_target_port_group(int fd)
 			return -RTPG_RTPG_FAILED;
 		}
 		buflen = scsi_buflen;
+		if (buflen_ptr)
+			*buflen_ptr = buflen;
 		memset(buf, 0, buflen);
 		rc = do_inquiry(fd, 1, 0x83, buf, buflen);
 		if (rc < 0)
@@ -269,7 +276,7 @@ do_rtpg(int fd, void* resp, long resplen
 }
 
 int
-get_asymmetric_access_state(int fd, unsigned int tpg)
+get_asymmetric_access_state(int fd, unsigned int tpg, int *buflen_ptr)
 {
 	unsigned char		*buf;
 	struct rtpg_data *	tpgd;
@@ -278,7 +285,12 @@ get_asymmetric_access_state(int fd, unsi
 	int			buflen;
 	uint32_t		scsi_buflen;
 
-	buflen = 128; /* Initial value from old code */
+	if (!buflen_ptr || *buflen_ptr == 0) {
+		buflen = 128; /* Initial value from old code */
+		if (buflen_ptr)
+			*buflen_ptr = 128;
+	} else
+		buflen = *buflen_ptr;
 	buf = (unsigned char *)malloc(buflen);
 	if (!buf) {
 		PRINT_DEBUG ("malloc failed: could not allocate"
@@ -299,6 +311,8 @@ get_asymmetric_access_state(int fd, unsi
 			return -RTPG_RTPG_FAILED;
 		}
 		buflen = scsi_buflen;
+		if (buflen_ptr)
+			*buflen_ptr = buflen;
 		memset(buf, 0, buflen);
 		rc = do_rtpg(fd, buf, buflen);
 		if (rc < 0)
Index: multipath-tools/libmultipath/prioritizers/alua_rtpg.h
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/alua_rtpg.h
+++ multipath-tools/libmultipath/prioritizers/alua_rtpg.h
@@ -23,8 +23,8 @@
 #define RTPG_TPG_NOT_FOUND			4
 
 int get_target_port_group_support(int fd);
-int get_target_port_group(int fd);
-int get_asymmetric_access_state(int fd, unsigned int tpg);
+int get_target_port_group(int fd, int *buflen_ptr);
+int get_asymmetric_access_state(int fd, unsigned int tpg, int *buflen_ptr);
 
 #endif /* __RTPG_H__ */
 
Index: multipath-tools/libmultipath/prioritizers/const.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/const.c
+++ multipath-tools/libmultipath/prioritizers/const.c
@@ -1,8 +1,12 @@
 #include <stdio.h>
 #include <structs.h>
 #include <prio.h>
+#include "def_func.h"
 
 int getprio (struct path * pp)
 {
 	return 1;
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
Index: multipath-tools/libmultipath/prioritizers/def_func.h
===================================================================
--- /dev/null
+++ multipath-tools/libmultipath/prioritizers/def_func.h
@@ -0,0 +1,11 @@
+#ifndef _DEF_FUNC_H
+#define _DEF_FUNC_H
+
+#include "prio.h"
+
+#define declare_nop_prio(name)						\
+int name (struct prio *p)						\
+{									\
+	return 0;							\
+}
+#endif /* _DEF_FUNC_H */
Index: multipath-tools/libmultipath/prioritizers/emc.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/emc.c
+++ multipath-tools/libmultipath/prioritizers/emc.c
@@ -6,6 +6,7 @@
 #include <debug.h>
 #include <structs.h>
 #include <prio.h>
+#include "def_func.h"
 
 #define INQUIRY_CMD     0x12
 #define INQUIRY_CMDLEN  6
@@ -78,3 +79,6 @@ int getprio (struct path * pp)
 {
 	return emc_clariion_prio(pp->dev, pp->fd);
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
Index: multipath-tools/libmultipath/prioritizers/hds.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/hds.c
+++ multipath-tools/libmultipath/prioritizers/hds.c
@@ -76,6 +76,7 @@
 #include <debug.h>
 #include <structs.h>
 #include <prio.h>
+#include "def_func.h"
 
 #define INQ_REPLY_LEN 255
 #define INQ_CMD_CODE 0x12
@@ -169,3 +170,6 @@ int getprio (struct path * pp)
 {
 	return hds_modular_prio(pp->dev, pp->fd);
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
Index: multipath-tools/libmultipath/prioritizers/hp_sw.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/hp_sw.c
+++ multipath-tools/libmultipath/prioritizers/hp_sw.c
@@ -16,6 +16,7 @@
 #include <debug.h>
 #include <prio.h>
 #include <structs.h>
+#include "def_func.h"
 
 #define TUR_CMD_LEN		6
 #define SCSI_CHECK_CONDITION	0x2
@@ -99,3 +100,6 @@ int getprio (struct path * pp)
 {
 	return hp_sw_prio(pp->dev, pp->fd);
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
Index: multipath-tools/libmultipath/prioritizers/ontap.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/ontap.c
+++ multipath-tools/libmultipath/prioritizers/ontap.c
@@ -23,6 +23,7 @@
 #include <debug.h>
 #include <structs.h>
 #include <prio.h>
+#include "def_func.h"
 
 #define INQUIRY_CMD	0x12
 #define INQUIRY_CMDLEN	6
@@ -244,3 +245,6 @@ int getprio (struct path * pp)
 {
 	return ontap_prio(pp->dev, pp->fd);
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
Index: multipath-tools/libmultipath/prioritizers/random.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/random.c
+++ multipath-tools/libmultipath/prioritizers/random.c
@@ -5,6 +5,7 @@
 
 #include <structs.h>
 #include <prio.h>
+#include "def_func.h"
 
 int getprio (struct path * pp)
 {
@@ -14,3 +15,6 @@ int getprio (struct path * pp)
 	srand((unsigned int)tv.tv_usec);
 	return 1+(int) (10.0*rand()/(RAND_MAX+1.0));
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
Index: multipath-tools/libmultipath/prioritizers/rdac.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/rdac.c
+++ multipath-tools/libmultipath/prioritizers/rdac.c
@@ -6,6 +6,7 @@
 #include <debug.h>
 #include <structs.h>
 #include <prio.h>
+#include "def_func.h"
 
 #define INQUIRY_CMD     0x12
 #define INQUIRY_CMDLEN  6
@@ -94,3 +95,6 @@ int getprio (struct path * pp)
 {
 	return rdac_prio(pp->dev, pp->fd);
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -347,10 +347,10 @@ detect_prio(struct path * pp)
 
 	if (get_target_port_group_support(pp->fd) <= 0)
 		return;
-	ret = get_target_port_group(pp->fd);
+	ret = get_target_port_group(pp->fd, NULL);
 	if (ret < 0)
 		return;
-	if (get_asymmetric_access_state(pp->fd, ret) < 0)
+	if (get_asymmetric_access_state(pp->fd, ret, NULL) < 0)
 		return;
 	prio_get(p, PRIO_ALUA);
 }
Index: multipath-tools/multipathd/main.c
===================================================================
--- multipath-tools.orig/multipathd/main.c
+++ multipath-tools/multipathd/main.c
@@ -379,6 +379,9 @@ uev_check_for_rw (struct sysfs_device * 
 
 	if (!pp || !pp->mpp) /* not a multipath path device */
 		return 0;
+	/* reinit the prio values on change event, in case something is
+	 * different */
+	prio_init(&pp->prio);
 	mpp = pp->mpp;
 	if (mpp->reload_readwrite != RELOAD_RW_ON || !mpp->dmi ||
 	    !mpp->dmi->read_only)
@@ -1209,6 +1212,11 @@ check_path (struct vectors * vecs, struc
 			return;
 
 		if(newstate == PATH_UP || newstate == PATH_GHOST){
+		 	/*
+			 * Reinitialize the prioritizer, in case something
+		 	 * changed.
+		 	 */
+			prio_init(&pp->prio);
 			if ( pp->mpp && pp->mpp->prflag ){
 				/*
 				 * Check Persistent Reservation.
Index: multipath-tools/libmultipath/prioritizers/weighted.c
===================================================================
--- multipath-tools.orig/libmultipath/prioritizers/weighted.c
+++ multipath-tools/libmultipath/prioritizers/weighted.c
@@ -33,6 +33,7 @@
 #include <regex.h>
 
 #include "weighted.h"
+#include "def_func.h"
 
 #define DEFAULT_WEIGHTED_PRIO 0
 
@@ -138,3 +139,6 @@ getprio(struct path * pp)
 {
 	return prio_weighted(pp);
 }
+
+declare_nop_prio(initprio)
+declare_nop_prio(freeprio)
