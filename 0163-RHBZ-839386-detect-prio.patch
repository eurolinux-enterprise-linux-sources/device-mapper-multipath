---
 libmultipath/Makefile      |    2 -
 libmultipath/config.c      |    3 +
 libmultipath/config.h      |    2 +
 libmultipath/defaults.h    |    1 
 libmultipath/dict.c        |   74 +++++++++++++++++++++++++++++++++++++++++++++
 libmultipath/discovery.c   |    1 
 libmultipath/propsel.c     |   37 ++++++++++++++++++++++
 libmultipath/propsel.h     |    1 
 libmultipath/structs.h     |    7 ++++
 multipath/multipath.conf.5 |   11 ++++++
 10 files changed, 138 insertions(+), 1 deletion(-)

Index: multipath-tools/libmultipath/config.c
===================================================================
--- multipath-tools.orig/libmultipath/config.c
+++ multipath-tools/libmultipath/config.c
@@ -313,6 +313,7 @@ merge_hwe (struct hwentry * hwe1, struct
 	merge_num(dev_loss);
 	merge_num(user_friendly_names);
 	merge_num(retain_hwhandler);
+	merge_num(detect_prio);
 
 	return 0;
 }
@@ -367,6 +368,7 @@ store_hwe (vector hwtable, struct hwentr
 	hwe->dev_loss = dhwe->dev_loss;
 	hwe->user_friendly_names = dhwe->user_friendly_names;
 	hwe->retain_hwhandler = dhwe->retain_hwhandler;
+	hwe->detect_prio = dhwe->detect_prio;
 
 	if (dhwe->bl_product && !(hwe->bl_product = set_param_str(dhwe->bl_product)))
 		goto out;
@@ -491,6 +493,7 @@ load_config (char * file)
 	conf->attribute_flags = 0;
 	conf->find_multipaths = DEFAULT_FIND_MULTIPATHS;
 	conf->retain_hwhandler = DEFAULT_RETAIN_HWHANDLER;
+	conf->detect_prio = DEFAULT_DETECT_PRIO;
 
 	/*
 	 * preload default hwtable
Index: multipath-tools/libmultipath/config.h
===================================================================
--- multipath-tools.orig/libmultipath/config.h
+++ multipath-tools/libmultipath/config.h
@@ -39,6 +39,7 @@ struct hwentry {
 	unsigned int dev_loss;
 	int user_friendly_names;
 	int retain_hwhandler;
+	int detect_prio;
 	char * bl_product;
 };
 
@@ -104,6 +105,7 @@ struct config {
 	mode_t mode;
 	uint32_t cookie;
 	int retain_hwhandler;
+	int detect_prio;
 
 	char * dev;
 	char * sysfs_dir;
Index: multipath-tools/libmultipath/defaults.h
===================================================================
--- multipath-tools.orig/libmultipath/defaults.h
+++ multipath-tools/libmultipath/defaults.h
@@ -15,6 +15,7 @@
 #define DEFAULT_VERBOSITY	2
 #define DEFAULT_FIND_MULTIPATHS 0
 #define DEFAULT_RETAIN_HWHANDLER RETAIN_HWHANDLER_OFF
+#define DEFAULT_DETECT_PRIO DETECT_PRIO_OFF
 
 #define DEFAULT_CHECKINT	5
 #define MAX_CHECKINT(a)		(a << 2)
Index: multipath-tools/libmultipath/dict.c
===================================================================
--- multipath-tools.orig/libmultipath/dict.c
+++ multipath-tools/libmultipath/dict.c
@@ -642,6 +642,29 @@ def_retain_hwhandler_handler(vector strv
 	return 0;
 }
 
+static int
+def_detect_prio_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		conf->detect_prio = DETECT_PRIO_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		conf->detect_prio = DETECT_PRIO_ON;
+	else
+		conf->detect_prio = DETECT_PRIO_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * blacklist block handlers
  */
@@ -1267,6 +1290,33 @@ hw_retain_hwhandler_handler(vector strve
 	return 0;
 }
 
+static int
+hw_detect_prio_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->detect_prio = DETECT_PRIO_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		hwe->detect_prio = DETECT_PRIO_ON;
+	else
+		hwe->detect_prio = DETECT_PRIO_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * multipaths block handlers
  */
@@ -2239,6 +2289,19 @@ snprint_hw_retain_hwhandler(char * buff,
 }
 
 static int
+snprint_detect_prio(char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->detect_prio == DETECT_PRIO_ON)
+		return snprintf(buff, len, "yes");
+	else if (hwe->detect_prio == DETECT_PRIO_OFF)
+		return snprintf(buff, len, "no");
+	else
+		return 0;
+}
+
+static int
 snprint_def_polling_interval (char * buff, int len, void * data)
 {
 	return snprintf(buff, len, "%i", conf->checkint);
@@ -2553,6 +2616,15 @@ snprint_def_retain_hwhandler(char * buff
 }
 
 static int
+snprint_def_detect_prio(char * buff, int len, void * data)
+{
+	if (conf->detect_prio == DETECT_PRIO_ON)
+		return snprintf(buff, len, "yes");
+	else
+		return snprintf(buff, len, "no");
+}
+
+static int
 snprint_ble_simple (char * buff, int len, void * data)
 {
 	struct blentry * ble = (struct blentry *)data;
@@ -2611,6 +2683,7 @@ init_keywords(void)
 	install_keyword("log_checker_err", &def_log_checker_err_handler, &snprint_def_log_checker_err);
 	install_keyword("reservation_key", &def_reservation_key_handler, &snprint_def_reservation_key);
 	install_keyword("retain_attached_hw_handler", &def_retain_hwhandler_handler, &snprint_def_retain_hwhandler);
+	install_keyword("detect_prio", &def_detect_prio_handler, &snprint_def_detect_prio);
 	__deprecated install_keyword("mode", &def_mode_handler, &snprint_def_mode);
 	__deprecated install_keyword("uid", &def_uid_handler, &snprint_def_uid);
 	__deprecated install_keyword("gid", &def_gid_handler, &snprint_def_gid);
@@ -2674,6 +2747,7 @@ init_keywords(void)
 	install_keyword("dev_loss_tmo", &hw_dev_loss_handler, &snprint_hw_dev_loss);
 	install_keyword("user_friendly_names", &hw_names_handler, &snprint_hw_user_friendly_names);
 	install_keyword("retain_attached_hw_handler", &hw_retain_hwhandler_handler, &snprint_hw_retain_hwhandler);
+	install_keyword("detect_prio", &hw_detect_prio_handler, &snprint_detect_prio);
 	install_sublevel_end();
 
 	install_keyword_root("multipaths", &multipaths_handler);
Index: multipath-tools/libmultipath/structs.h
===================================================================
--- multipath-tools.orig/libmultipath/structs.h
+++ multipath-tools/libmultipath/structs.h
@@ -106,6 +106,12 @@ enum retain_hwhandler_states {
 	RETAIN_HWHANDLER_ON,
 };
 
+enum detect_prio_states {
+	DETECT_PRIO_UNDEF,
+	DETECT_PRIO_OFF,
+	DETECT_PRIO_ON,
+};
+
 struct scsi_idlun {
 	int dev_id;
 	int host_unique_id;
@@ -161,6 +167,7 @@ struct path {
 	int failcount;
 	int priority;
 	int pgindex;
+	int detect_prio;
 	char * getuid;
 	char * prio_args;
 	struct prio * prio;
Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -17,6 +17,7 @@
 #include "devmapper.h"
 #include "prio.h"
 #include "discovery.h"
+#include "prioritizers/alua_rtpg.h"
 #include <inttypes.h>
 
 pgpolicyfn *pgpolicies[] = {
@@ -329,11 +330,29 @@ select_getuid (struct path * pp)
 	return 0;
 }
 
+struct prio *
+detect_prio(struct path * pp)
+{
+	if (get_target_port_group_support(pp->fd) > 0)
+		return prio_lookup(PRIO_ALUA);
+	return NULL;
+}
+
 extern int
 select_prio (struct path * pp)
 {
 	struct mpentry * mpe;
 
+	if (pp->detect_prio == DETECT_PRIO_ON) {
+		pp->prio = detect_prio(pp);
+		if (pp->prio) {
+			pp->prio_args = NULL;
+			condlog(3, "%s: prio = %s (detected setting)",
+				pp->dev, pp->prio->name);
+			return 0;
+		}
+	}
+
 	if ((mpe = find_mpe(pp->wwid)) && mpe->prio_name) {
 		pp->prio = prio_lookup(mpe->prio_name);
 		pp->prio_args = mpe->prio_args;
@@ -626,3 +645,21 @@ select_retain_hwhandler (struct multipat
 	condlog(3, "%s: retain_attached_hw_handler = %d (compiled in default)", mp->alias, mp->retain_hwhandler);
 	return 0;
 }
+
+extern int
+select_detect_prio (struct path * pp)
+{
+	if (pp->hwe && pp->hwe->detect_prio) {
+		pp->detect_prio = pp->hwe->detect_prio;
+		condlog(3, "%s: detect_prio = %d (controller default)", pp->dev, pp->detect_prio);
+		return 0;
+	}
+	if (conf->detect_prio) {
+		pp->detect_prio = conf->detect_prio;
+		condlog(3, "%s: detect_prio = %d (config file default)", pp->dev, pp->detect_prio);
+		return 0;
+	}
+	pp->detect_prio = 0;
+	condlog(3, "%s: detect_prio = %d (compiled in default)", pp->dev, pp->detect_prio);
+	return 0;
+}
Index: multipath-tools/libmultipath/Makefile
===================================================================
--- multipath-tools.orig/libmultipath/Makefile
+++ multipath-tools/libmultipath/Makefile
@@ -12,7 +12,7 @@ OBJS = memory.o parser.o vector.o devmap
        pgpolicies.o debug.o regex.o defaults.o uevent.o \
        switchgroup.o uxsock.o print.o alias.o log_pthread.o \
        log.o configure.o structs_vec.o sysfs.o prio.o checkers.o \
-       lock.o waiter.o file.o finder.o
+       lock.o waiter.o file.o finder.o prioritizers/alua_rtpg.o
 
 LIBDM_API_FLUSH = $(shell if test -d /lib64 ; then objdump -T /lib64/libdevmapper.so* ; else objdump -T /lib/libdevmapper.so.* ; fi | grep -c dm_task_no_flush)
 
Index: multipath-tools/libmultipath/discovery.c
===================================================================
--- multipath-tools.orig/libmultipath/discovery.c
+++ multipath-tools/libmultipath/discovery.c
@@ -912,6 +912,7 @@ get_prio (struct path * pp)
 	if (!pp->prio) {
 		if (!strlen(pp->wwid))
 			get_uid(pp);
+		select_detect_prio(pp);
 		select_prio(pp);
 		if (!pp->prio) {
 			condlog(3, "%s: no prio selected", pp->dev);
Index: multipath-tools/libmultipath/propsel.h
===================================================================
--- multipath-tools.orig/libmultipath/propsel.h
+++ multipath-tools/libmultipath/propsel.h
@@ -19,3 +19,4 @@ int select_fast_io_fail(struct multipath
 int select_dev_loss(struct multipath *mp);
 int select_reservation_key(struct multipath *mp);
 int select_retain_hwhandler (struct multipath * mp);
+int select_detect_prio(struct path * pp);
Index: multipath-tools/multipath/multipath.conf.5
===================================================================
--- multipath-tools.orig/multipath/multipath.conf.5
+++ multipath-tools/multipath/multipath.conf.5
@@ -393,6 +393,15 @@ multipath will not force the device to u
 mutipath.conf. If the scsi layer has not attached a hardware handler,
 multipath will continue to use its configured hardware handler. Default is
 .I no
+.TP
+.B detect_prio
+If set to
+.I yes
+, multipath will try to detect if the device supports ALUA. If so, the device
+will automatically use the
+.I alua
+prioritizer. If not, the prioritizer will be selected as usual. Default is
+.I no
 .
 .SH "blacklist section"
 The
@@ -569,6 +578,8 @@ section:
 .B flush_on_last_del
 .TP
 .B retain_attached_hw_handler
+.TP
+.B detect_prio
 .RE
 .PD
 .LP
