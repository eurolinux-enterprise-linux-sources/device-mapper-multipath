---
 libmultipath/checkers.c    |    3 
 libmultipath/checkers.h    |    9 ++
 libmultipath/config.c      |    4 
 libmultipath/config.h      |    6 +
 libmultipath/configure.c   |    2 
 libmultipath/defaults.h    |    1 
 libmultipath/dict.c        |  201 +++++++++++++++++++++++++++++++++++++++++++++
 libmultipath/print.c       |    2 
 libmultipath/propsel.c     |   52 +++++++++++
 libmultipath/propsel.h     |    2 
 libmultipath/structs.h     |    9 ++
 multipath.conf.annotated   |   39 ++++++++
 multipath.conf.defaults    |    2 
 multipath/multipath.conf.5 |   27 ++++++
 multipathd/main.c          |   33 ++++++-
 15 files changed, 385 insertions(+), 7 deletions(-)

Index: multipath-tools/libmultipath/config.h
===================================================================
--- multipath-tools.orig/libmultipath/config.h
+++ multipath-tools/libmultipath/config.h
@@ -42,6 +42,8 @@ struct hwentry {
 	int retain_hwhandler;
 	int detect_prio;
 	int reload_readwrite;
+	int delay_watch_checks;
+	int delay_wait_checks;
 	char * bl_product;
 };
 
@@ -64,6 +66,8 @@ struct mpentry {
 	int flush_on_last_del;
 	int attribute_flags;
 	int user_friendly_names;
+	int delay_watch_checks;
+	int delay_wait_checks;
 	uid_t uid;
 	gid_t gid;
 	mode_t mode;
@@ -112,6 +116,8 @@ struct config {
 	int replace_wwid_whitespace;
 	int force_sync;
 	int processed_main_config;
+	int delay_watch_checks;
+	int delay_wait_checks;
 
 	char * dev;
 	char * sysfs_dir;
Index: multipath-tools/libmultipath/structs.h
===================================================================
--- multipath-tools.orig/libmultipath/structs.h
+++ multipath-tools/libmultipath/structs.h
@@ -119,6 +119,11 @@ enum reload_readwrite_states {
 	RELOAD_RW_ON,
 };
 
+enum delay_checks_states {
+	DELAY_CHECKS_OFF = -1,
+	DELAY_CHECKS_UNDEF = 0,
+};
+
 struct scsi_idlun {
 	int dev_id;
 	int host_unique_id;
@@ -183,6 +188,8 @@ struct path {
 	int priority;
 	int pgindex;
 	int detect_prio;
+	int watch_checks;
+	int wait_checks;
 	char * getuid;
 	char * prio_args;
 	struct prio * prio;
@@ -218,6 +225,8 @@ struct multipath {
 	int fast_io_fail;
 	int retain_hwhandler;
 	int reload_readwrite;
+	int delay_watch_checks;
+	int delay_wait_checks;
 	unsigned int dev_loss;
 	uid_t uid;
 	gid_t gid;
Index: multipath-tools/libmultipath/checkers.h
===================================================================
--- multipath-tools.orig/libmultipath/checkers.h
+++ multipath-tools/libmultipath/checkers.h
@@ -46,6 +46,14 @@
  * PATH_PENDING:
  * - Use: All async checkers
  * - Description: Indicates a check IO is in flight.
+ *
+ * PATH_DELAYED:
+ * - Use: None of the checkers (returned if the path is being delayed before
+ *   reintegration.
+ * - Description: If a path fails after being up for less than
+ *   delay_watch_checks checks, when it comes back up again, it will not
+ *   be marked as up until it has been up for delay_wait_checks checks.
+ *   During this time, it is marked as "delayed"
  */
 enum path_check_state {
 	PATH_WILD,
@@ -55,6 +63,7 @@ enum path_check_state {
 	PATH_SHAKY,
 	PATH_GHOST,
 	PATH_PENDING,
+	PATH_DELAYED,
 	PATH_MAX_STATE
 };
 
Index: multipath-tools/libmultipath/configure.c
===================================================================
--- multipath-tools.orig/libmultipath/configure.c
+++ multipath-tools/libmultipath/configure.c
@@ -288,6 +288,8 @@ setup_map (struct multipath * mpp)
 	select_reservation_key(mpp);
 	select_retain_hwhandler(mpp);
 	select_reload_readwrite(mpp);
+	select_delay_watch_checks(mpp);
+	select_delay_wait_checks(mpp);
 
 	sysfs_set_scsi_tmo(mpp);
 	/*
Index: multipath-tools/libmultipath/defaults.h
===================================================================
--- multipath-tools.orig/libmultipath/defaults.h
+++ multipath-tools/libmultipath/defaults.h
@@ -18,6 +18,7 @@
 #define DEFAULT_RETAIN_HWHANDLER RETAIN_HWHANDLER_OFF
 #define DEFAULT_DETECT_PRIO DETECT_PRIO_OFF
 #define DEFAULT_RELOAD_RW RELOAD_RW_OFF
+#define DEFAULT_DELAY_CHECKS    DELAY_CHECKS_OFF
 
 #define DEFAULT_CHECKINT	5
 #define MAX_CHECKINT(a)		(a << 2)
Index: multipath-tools/libmultipath/dict.c
===================================================================
--- multipath-tools.orig/libmultipath/dict.c
+++ multipath-tools/libmultipath/dict.c
@@ -748,6 +748,44 @@ def_force_sync_handler(vector strvec)
 	return 0;
 }
 
+static int
+def_delay_watch_checks_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		conf->delay_watch_checks = DELAY_CHECKS_OFF;
+	else if ((conf->delay_watch_checks = atoi(buff)) < 1)
+		conf->delay_watch_checks = DELAY_CHECKS_OFF;
+
+	FREE(buff);
+	return 0;
+}
+
+static int
+def_delay_wait_checks_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		conf->delay_wait_checks = DELAY_CHECKS_OFF;
+	else if ((conf->delay_wait_checks = atoi(buff)) < 1)
+		conf->delay_wait_checks = DELAY_CHECKS_OFF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * blacklist block handlers
  */
@@ -1434,6 +1472,52 @@ hw_reload_readwrite_handler(vector strve
 	return 0;
 }
 
+static int
+hw_delay_watch_checks_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->delay_watch_checks = DELAY_CHECKS_OFF;
+	else if ((hwe->delay_watch_checks = atoi(buff)) < 1)
+		hwe->delay_watch_checks = DELAY_CHECKS_OFF;
+
+	FREE(buff);
+	return 0;
+}
+
+static int
+hw_delay_wait_checks_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->delay_wait_checks = DELAY_CHECKS_OFF;
+	else if ((hwe->delay_wait_checks = atoi(buff)) < 1)
+		hwe->delay_wait_checks = DELAY_CHECKS_OFF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * multipaths block handlers
  */
@@ -1867,6 +1951,52 @@ mp_reservation_key_handler (vector strve
 	return 0;
 }
 
+static int
+mp_delay_watch_checks_handler(vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+	char * buff;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		mpe->delay_watch_checks = DELAY_CHECKS_OFF;
+	else if ((mpe->delay_watch_checks = atoi(buff)) < 1)
+		mpe->delay_watch_checks = DELAY_CHECKS_OFF;
+
+	FREE(buff);
+	return 0;
+}
+
+static int
+mp_delay_wait_checks_handler(vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+	char * buff;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		mpe->delay_wait_checks = DELAY_CHECKS_OFF;
+	else if ((mpe->delay_wait_checks = atoi(buff)) < 1)
+		mpe->delay_wait_checks = DELAY_CHECKS_OFF;
+
+	FREE(buff);
+	return 0;
+}
+
 
 /*
  * config file keywords printing
@@ -2092,6 +2222,29 @@ snprint_mp_reservation_key (char * buff,
 	return snprintf(buff, len, "0x%" PRIx64, prkey);
 }
 
+static int
+snprint_mp_delay_watch_checks(char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (mpe->delay_watch_checks == DELAY_CHECKS_UNDEF)
+		return 0;
+	if (mpe->delay_watch_checks == DELAY_CHECKS_OFF)
+		return snprintf(buff, len, "no");
+	return snprintf(buff, len, "%d", mpe->delay_watch_checks);
+}
+
+static int
+snprint_mp_delay_wait_checks(char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (mpe->delay_wait_checks == DELAY_CHECKS_UNDEF)
+		return 0;
+	if (mpe->delay_wait_checks == DELAY_CHECKS_OFF)
+		return snprintf(buff, len, "no");
+	return snprintf(buff, len, "%d", mpe->delay_wait_checks);
+}
 
 static int
 snprint_hw_fast_io_fail(char * buff, int len, void * data)
@@ -2412,6 +2565,30 @@ snprint_hw_reload_readwrite(char *buff, 
 }
 
 static int
+snprint_hw_delay_watch_checks(char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->delay_watch_checks == DELAY_CHECKS_UNDEF)
+		return 0;
+	if (hwe->delay_watch_checks == DELAY_CHECKS_OFF)
+		return snprintf(buff, len, "no");
+	return snprintf(buff, len, "%d", hwe->delay_watch_checks);
+}
+
+static int
+snprint_hw_delay_wait_checks(char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->delay_wait_checks == DELAY_CHECKS_UNDEF)
+		return 0;
+	if (hwe->delay_wait_checks == DELAY_CHECKS_OFF)
+		return snprintf(buff, len, "no");
+	return snprintf(buff, len, "%d", hwe->delay_wait_checks);
+}
+
+static int
 snprint_def_polling_interval (char * buff, int len, void * data)
 {
 	return snprintf(buff, len, "%i", conf->checkint);
@@ -2778,6 +2955,24 @@ snprint_def_config_dir (char * buff, int
 }
 
 static int
+snprint_def_delay_watch_checks(char * buff, int len, void * data)
+{
+	if (conf->delay_watch_checks == DELAY_CHECKS_UNDEF ||
+	    conf->delay_watch_checks == DELAY_CHECKS_OFF)
+		return snprintf(buff, len, "no");
+	return snprintf(buff, len, "%d", conf->delay_watch_checks);
+}
+
+static int
+snprint_def_delay_wait_checks(char * buff, int len, void * data)
+{
+	if (conf->delay_wait_checks == DELAY_CHECKS_UNDEF ||
+	    conf->delay_wait_checks == DELAY_CHECKS_OFF)
+		return snprintf(buff, len, "no");
+	return snprintf(buff, len, "%d", conf->delay_wait_checks);
+}
+
+static int
 snprint_ble_simple (char * buff, int len, void * data)
 {
 	struct blentry * ble = (struct blentry *)data;
@@ -2841,6 +3036,8 @@ init_keywords(void)
 	install_keyword("replace_wwid_whitespace", &def_replace_wwid_whitespace_handler, &snprint_def_replace_wwid_whitespace);
 	install_keyword("force_sync", &def_force_sync_handler, &snprint_def_force_sync);
 	install_keyword("config_dir", &def_config_dir_handler, &snprint_def_config_dir);
+	install_keyword("delay_watch_checks", &def_delay_watch_checks_handler, &snprint_def_delay_watch_checks);
+	install_keyword("delay_wait_checks", &def_delay_wait_checks_handler, &snprint_def_delay_wait_checks);
 	__deprecated install_keyword("mode", &def_mode_handler, &snprint_def_mode);
 	__deprecated install_keyword("uid", &def_uid_handler, &snprint_def_uid);
 	__deprecated install_keyword("gid", &def_gid_handler, &snprint_def_gid);
@@ -2907,6 +3104,8 @@ init_keywords(void)
 	install_keyword("retain_attached_hw_handler", &hw_retain_hwhandler_handler, &snprint_hw_retain_hwhandler);
 	install_keyword("detect_prio", &hw_detect_prio_handler, &snprint_detect_prio);
 	install_keyword("reload_readwrite", &hw_reload_readwrite_handler, &snprint_hw_reload_readwrite);
+	install_keyword("delay_watch_checks", &hw_delay_watch_checks_handler, &snprint_hw_delay_watch_checks);
+	install_keyword("delay_wait_checks", &hw_delay_wait_checks_handler, &snprint_hw_delay_wait_checks);
 	install_sublevel_end();
 
 	install_keyword_root("multipaths", &multipaths_handler);
@@ -2929,5 +3128,7 @@ init_keywords(void)
 	install_keyword("prio", &mp_prio_handler, &snprint_mp_prio);
 	install_keyword("user_friendly_names", &mp_names_handler, &snprint_mp_user_friendly_names);
 	install_keyword("reservation_key", &mp_reservation_key_handler, &snprint_mp_reservation_key);
+	install_keyword("delay_watch_checks", &mp_delay_watch_checks_handler, &snprint_mp_delay_watch_checks);
+	install_keyword("delay_wait_checks", &mp_delay_wait_checks_handler, &snprint_mp_delay_wait_checks);
 	install_sublevel_end();
 }
Index: multipath-tools/libmultipath/print.c
===================================================================
--- multipath-tools.orig/libmultipath/print.c
+++ multipath-tools/libmultipath/print.c
@@ -334,6 +334,8 @@ snprint_chk_state (char * buff, size_t l
 		return snprintf(buff, len, "shaky");
 	case PATH_GHOST:
 		return snprintf(buff, len, "ghost");
+	case PATH_DELAYED:
+		return snprintf(buff, len, "delayed");
 	default:
 		return snprintf(buff, len, "undef");
 	}
Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -700,3 +700,55 @@ select_reload_readwrite (struct multipat
 		mp->alias, mp->reload_readwrite);
 	return 0;
 }
+
+extern int
+select_delay_watch_checks (struct multipath * mp)
+{
+	if (mp->mpe && mp->mpe->delay_watch_checks != DELAY_CHECKS_UNDEF) {
+		mp->delay_watch_checks = mp->mpe->delay_watch_checks;
+		condlog(3, "delay_watch_checks = %i (multipath setting)",
+				mp->delay_watch_checks);
+		return 0;
+	}
+	if (mp->hwe && mp->hwe->delay_watch_checks != DELAY_CHECKS_UNDEF) {
+		mp->delay_watch_checks = mp->hwe->delay_watch_checks;
+		condlog(3, "delay_watch_checks = %i (controler setting)",
+				mp->delay_watch_checks);
+		return 0;
+	}
+	if (conf->delay_watch_checks != DELAY_CHECKS_UNDEF) {
+		mp->delay_watch_checks = conf->delay_watch_checks;
+		condlog(3, "delay_watch_checks = %i (config file default)",
+				mp->delay_watch_checks);
+		return 0;
+	}
+	mp->delay_watch_checks = DEFAULT_DELAY_CHECKS;
+	condlog(3, "delay_watch_checks = DISABLED (internal default)");
+	return 0;
+}
+
+extern int
+select_delay_wait_checks (struct multipath * mp)
+{
+	if (mp->mpe && mp->mpe->delay_wait_checks != DELAY_CHECKS_UNDEF) {
+		mp->delay_wait_checks = mp->mpe->delay_wait_checks;
+		condlog(3, "delay_wait_checks = %i (multipath setting)",
+				mp->delay_wait_checks);
+		return 0;
+	}
+	if (mp->hwe && mp->hwe->delay_wait_checks != DELAY_CHECKS_UNDEF) {
+		mp->delay_wait_checks = mp->hwe->delay_wait_checks;
+		condlog(3, "delay_wait_checks = %i (controler setting)",
+				mp->delay_wait_checks);
+		return 0;
+	}
+	if (conf->delay_wait_checks != DELAY_CHECKS_UNDEF) {
+		mp->delay_wait_checks = conf->delay_wait_checks;
+		condlog(3, "delay_wait_checks = %i (config file default)",
+				mp->delay_wait_checks);
+		return 0;
+	}
+	mp->delay_wait_checks = DEFAULT_DELAY_CHECKS;
+	condlog(3, "delay_wait_checks = DISABLED (internal default)");
+	return 0;
+}
Index: multipath-tools/libmultipath/propsel.h
===================================================================
--- multipath-tools.orig/libmultipath/propsel.h
+++ multipath-tools/libmultipath/propsel.h
@@ -21,3 +21,5 @@ int select_reservation_key(struct multip
 int select_retain_hwhandler (struct multipath * mp);
 int select_detect_prio(struct path * pp);
 int select_reload_readwrite (struct multipath * mp);
+int select_delay_watch_checks (struct multipath * mp);
+int select_delay_wait_checks (struct multipath * mp);
Index: multipath-tools/multipathd/main.c
===================================================================
--- multipath-tools.orig/multipathd/main.c
+++ multipath-tools/multipathd/main.c
@@ -177,7 +177,8 @@ sync_map_state(struct multipath *mpp)
 	vector_foreach_slot (mpp->pg, pgp, i){
 		vector_foreach_slot (pgp->paths, pp, j){
 			if (pp->state == PATH_UNCHECKED || 
-			    pp->state == PATH_WILD)
+			    pp->state == PATH_WILD ||
+			    pp->state == PATH_DELAYED)
 				continue;
 			if ((pp->dmstate == PSTATE_FAILED ||
 			     pp->dmstate == PSTATE_UNDEF) &&
@@ -1147,6 +1148,15 @@ check_path (struct vectors * vecs, struc
 		pp->tick = 1;
 		return;
 	}
+	if ((newstate == PATH_UP || newstate == PATH_GHOST) &&
+	    pp->wait_checks > 0) {
+		if (pp->mpp && pp->mpp->nr_active > 0) {
+			pp->state = PATH_DELAYED;
+			pp->wait_checks--;
+			return;
+		} else
+			pp->wait_checks = 0;
+	}
 	pp->chkrstate = newstate;
 	if (newstate != pp->state) {
 		int oldstate = pp->state;
@@ -1170,9 +1180,14 @@ check_path (struct vectors * vecs, struc
 			 * proactively fail path in the DM
 			 */
 			if (oldstate == PATH_UP ||
-			    oldstate == PATH_GHOST)
+			    oldstate == PATH_GHOST) {
 				fail_path(pp, 1);
-			else
+				if (pp->mpp->delay_wait_checks > 0 &&
+				    pp->watch_checks > 0) {
+					pp->wait_checks = pp->mpp->delay_wait_checks;
+					pp->watch_checks = 0;
+				}
+			}else
 				fail_path(pp, 0);
 
 			/*
@@ -1202,11 +1217,15 @@ check_path (struct vectors * vecs, struc
 		 * reinstate this path
 		 */
 		if (oldstate != PATH_UP &&
-		    oldstate != PATH_GHOST)
+		    oldstate != PATH_GHOST) {
+			if (pp->mpp->delay_watch_checks > 0)
+				pp->watch_checks = pp->mpp->delay_watch_checks;
 			reinstate_path(pp, 1);
-		else
+		} else {
+			if (pp->watch_checks > 0)
+				pp->watch_checks--;
 			reinstate_path(pp, 0);
-
+		}
 		new_path_up = 1;
 
 		if (oldchkrstate != PATH_UP && oldchkrstate != PATH_GHOST)
@@ -1230,6 +1249,8 @@ check_path (struct vectors * vecs, struc
 		else
 			pp->checkint = conf->max_checkint;
 
+		if (pp->watch_checks > 0)
+			pp->watch_checks--;
 		pp->tick = pp->checkint;
 		condlog(4, "%s: delay next check %is",
 				pp->dev_t, pp->tick);
Index: multipath-tools/multipath.conf.annotated
===================================================================
--- multipath-tools.orig/multipath.conf.annotated
+++ multipath-tools/multipath.conf.annotated
@@ -357,6 +357,30 @@
 #	#           files, just as if it was in /etc/multipath.conf
 #	# values  : "" or a fully qualified pathname
 #	# default : "/etc/multipath/conf.d"
+#
+#	#
+#	# name    : delay_watch_checks
+#	# scope   : multipathd
+#	# desc    : If set to a value greater than 0, multipathd will watch
+#	#           paths that have recently become valid for this many
+#	#           checks.  If they fail again while they are being watched,
+#	#           when they next become valid, they will not be used until
+#	#           they have stayed up for delay_wait_checks checks.
+#	# values  : no|<n> > 0
+#	# default : no
+#	delay_watch_checks 12
+#
+#	#
+#	# name    : delay_wait_checks
+#	# scope   : multipathd
+#	# desc    : If set to a value greater than 0, when a device that has
+#	#           recently come back online fails again within
+#	#           delay_watch_checks checks, the next time it comes back
+#	#           online, it will marked and delayed, and not used until
+#	#           it has passed delay_wait_checks checks.
+#	# values  : no|<n> > 0
+#	# default : no
+#	delay_wait_checks 12
 #}
 #	
 ##
@@ -465,6 +489,13 @@
 #		# name    : reservation_key
 #		# See defaults section for information.
 #
+#		#
+#		# name    : delay_watch_checks
+#		# See defualts section for information.
+#
+#		#
+#		# name    : delay_wait_checks
+#		# See defualts section for information.
 #	}
 #	multipath {
 #		wwid	1DEC_____321816758474
@@ -582,6 +613,14 @@
 #		# name    : reload_readwrite
 #		# See defaults section for information.
 #
+#		#
+#		# name    : delay_watch_checks
+#		# See defualts section for information.
+#
+#		#
+#		# name    : delay_wait_checks
+#		# See defualts section for information.
+#
 #	}
 #	device {
 #		vendor			"COMPAQ  "
Index: multipath-tools/multipath.conf.defaults
===================================================================
--- multipath-tools.orig/multipath.conf.defaults
+++ multipath-tools/multipath.conf.defaults
@@ -27,6 +27,8 @@
 #	reload_readwrite no
 #	replace_wwid_whitespace
 #	config_dir "/etc/multipath/conf.d"
+#	delay_watch_checks no
+#	delay_wait_checks no
 #}
 #blacklist {
 #	devnode "^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*"
Index: multipath-tools/multipath/multipath.conf.5
===================================================================
--- multipath-tools.orig/multipath/multipath.conf.5
+++ multipath-tools/multipath/multipath.conf.5
@@ -448,6 +448,25 @@ alphabetically for file ending in ".conf
 information from them, just as if it was in /etc/multipath.conf.  config_dir
 must either be "" or a fully qualified directory name. Default is
 .I "/etc/multipath/conf.d"
+.TP
+.B delay_watch_checks
+If set to a value greater than 0, multipathd will watch paths that have
+recently become valid for this many checks.  If they fail again while they are
+being watched, when they next become valid, they will not be used until they
+have stayed up for
+.I delay_wait_checks
+checks. Default is
+.I no
+.TP
+.B delay_wait_checks
+If set to a value greater than 0, when a device that has recently come back
+online fails again within
+.I delay_watch_checks
+checks, the next time it comes back online, it will marked and delayed, and not
+used until it has passed
+.I delay_wait_checks
+checks. Default is
+.I no
 .
 .SH "blacklist section"
 The
@@ -543,6 +562,10 @@ section:
 .B flush_on_last_del
 .TP
 .B reservation_key
+.TP
+.B delay_watch_checks
+.TP
+.B delay_wait_checks
 .RE
 .PD
 .LP
@@ -628,6 +651,10 @@ section:
 .B detect_prio
 .TP
 .B reload_readwrite
+.TP
+.B delay_watch_checks
+.TP
+.B delay_wait_checks
 .RE
 .PD
 .LP
Index: multipath-tools/libmultipath/checkers.c
===================================================================
--- multipath-tools.orig/libmultipath/checkers.c
+++ multipath-tools/libmultipath/checkers.c
@@ -15,7 +15,8 @@ char *checker_state_names[] = {
       "up",
       "shaky",
       "ghost",
-      "pending"
+      "pending",
+      "delayed"
 };
 
 static LIST_HEAD(checkers);
Index: multipath-tools/libmultipath/config.c
===================================================================
--- multipath-tools.orig/libmultipath/config.c
+++ multipath-tools/libmultipath/config.c
@@ -318,6 +318,8 @@ merge_hwe (struct hwentry * hwe1, struct
 	merge_num(retain_hwhandler);
 	merge_num(detect_prio);
 	merge_num(reload_readwrite);
+	merge_num(delay_watch_checks);
+	merge_num(delay_wait_checks);
 
 	return 0;
 }
@@ -363,6 +365,8 @@ overwrite_hwe (struct hwentry * dst, str
 	overwrite_num(retain_hwhandler);
 	overwrite_num(detect_prio);
 	overwrite_num(reload_readwrite);
+	overwrite_num(delay_watch_checks);
+	overwrite_num(delay_wait_checks);
 
 	if (dst->no_path_retry == NO_PATH_RETRY_FAIL && dst->features) {
 		char *tmp;
