---
 libmultipath/propsel.c |   20 ++++++++++++++++----
 libmultipath/structs.h |    1 +
 multipathd/main.c      |   32 +++++++++++++++++++++++---------
 3 files changed, 40 insertions(+), 13 deletions(-)

Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -344,9 +344,11 @@ detect_prio(struct path * pp)
 {
 	int ret;
 	struct prio *p = &pp->prio;
+	int tpgs = 0;
 
-	if (get_target_port_group_support(pp->fd) <= 0)
+	if ((tpgs = get_target_port_group_support(pp->fd)) <= 0)
 		return;
+	pp->tpgs = tpgs;
 	ret = get_target_port_group(pp->fd, NULL);
 	if (ret < 0)
 		return;
@@ -376,26 +378,36 @@ select_prio (struct path * pp)
 		pp->prio_args = mpe->prio_args;
 		condlog(3, "%s: prio = %s (LUN setting)",
 			pp->dev, mpe->prio_name);
-		return 0;
+		goto out;
 	}
 	if (pp->hwe && pp->hwe->prio_name) {
 		prio_get(p, pp->hwe->prio_name);
 		pp->prio_args = pp->hwe->prio_args;
 		condlog(3, "%s: prio = %s (controller setting)",
 			pp->dev, pp->hwe->prio_name);
-		return 0;
+		goto out;
 	}
 	if (conf->prio_name) {
 		prio_get(p, conf->prio_name);
 		pp->prio_args = conf->prio_args;
 		condlog(3, "%s: prio = %s (config file default)",
 			pp->dev, conf->prio_name);
-		return 0;
+		goto out;
 	}
 	prio_get(p, DEFAULT_PRIO);
 	pp->prio_args = NULL;
 	condlog(3, "%s: prio = %s (internal default)",
 		pp->dev, DEFAULT_PRIO);
+out:
+	/*
+	 * fetch tpgs mode for alua
+	 */
+	if (!strncmp(prio_name(p), PRIO_ALUA, PRIO_NAME_LEN)) {
+		int tpgs = 0;
+		if (!pp->tpgs &&
+		    (tpgs = get_target_port_group_support(pp->fd)) >= 0)
+			pp->tpgs = tpgs;
+	}
 	return 0;
 }
 
Index: multipath-tools/libmultipath/structs.h
===================================================================
--- multipath-tools.orig/libmultipath/structs.h
+++ multipath-tools/libmultipath/structs.h
@@ -196,6 +196,7 @@ struct path {
 	int detect_prio;
 	int watch_checks;
 	int wait_checks;
+	int tpgs;
 	char * getuid;
 	char * prio_args;
 	struct prio prio;
Index: multipath-tools/multipathd/main.c
===================================================================
--- multipath-tools.orig/multipathd/main.c
+++ multipath-tools/multipathd/main.c
@@ -17,6 +17,7 @@
 #include <limits.h>
 #include <linux/oom.h>
 #include <mpath_persist.h>
+#include "prioritizers/alua_rtpg.h"
 
 /*
  * libcheckers
@@ -1143,6 +1144,7 @@ check_path (struct vectors * vecs, struc
 	int newstate;
 	int new_path_up = 0;
 	int chkr_new_path_up = 0;
+	int disable_reinstate = 0;
 	int oldchkrstate = pp->chkrstate;
 
 	if (!pp->mpp)
@@ -1181,6 +1183,16 @@ check_path (struct vectors * vecs, struc
 		} else
 			pp->wait_checks = 0;
 	}
+	/*
+	 * don't reinstate failed path, if its in stand-by
+	 * and if target supports only implicit tpgs mode.
+	 * this will prevent unnecessary i/o by dm on stand-by
+	 * paths if there are no other active paths in map.
+	 */
+	disable_reinstate = (newstate == PATH_GHOST &&
+			    pp->mpp->nr_active == 0 &&
+			    pp->tpgs == TPGS_IMPLICIT) ? 1 : 0;
+
 	pp->chkrstate = newstate;
 	if (newstate != pp->state) {
 		int oldstate = pp->state;
@@ -1245,15 +1257,17 @@ check_path (struct vectors * vecs, struc
 		/*
 		 * reinstate this path
 		 */
-		if (oldstate != PATH_UP &&
-		    oldstate != PATH_GHOST) {
-			if (pp->mpp->delay_watch_checks > 0)
-				pp->watch_checks = pp->mpp->delay_watch_checks;
-			reinstate_path(pp, 1);
-		} else {
-			if (pp->watch_checks > 0)
-				pp->watch_checks--;
-			reinstate_path(pp, 0);
+		if (!disable_reinstate) {
+			if (oldstate != PATH_UP &&
+			    oldstate != PATH_GHOST) {
+				if (pp->mpp->delay_watch_checks > 0)
+					pp->watch_checks = pp->mpp->delay_watch_checks;
+				reinstate_path(pp, 1);
+			} else {
+				if (pp->watch_checks > 0)
+					pp->watch_checks--;
+				reinstate_path(pp, 0);
+			}
 		}
 		new_path_up = 1;
 
