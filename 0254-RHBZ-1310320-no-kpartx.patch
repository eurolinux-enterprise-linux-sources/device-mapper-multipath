---
 libmultipath/config.c      |    3 +
 libmultipath/config.h      |    3 +
 libmultipath/configure.c   |   20 ++++---
 libmultipath/defaults.h    |    1 
 libmultipath/devmapper.c   |   39 +++++++++------
 libmultipath/devmapper.h   |   14 +++--
 libmultipath/dict.c        |  114 +++++++++++++++++++++++++++++++++++++++++++++
 libmultipath/propsel.c     |   26 ++++++++++
 libmultipath/propsel.h     |    1 
 libmultipath/structs.h     |    7 ++
 multipath/multipath.conf.5 |   10 +++
 multipath/multipath.rules  |    1 
 multipathd/cli_handlers.c  |   18 ++++---
 multipathd/main.c          |    8 ++-
 14 files changed, 228 insertions(+), 37 deletions(-)

Index: multipath-tools/libmultipath/configure.c
===================================================================
--- multipath-tools.orig/libmultipath/configure.c
+++ multipath-tools/libmultipath/configure.c
@@ -290,6 +290,7 @@ setup_map (struct multipath * mpp)
 	select_reload_readwrite(mpp);
 	select_delay_watch_checks(mpp);
 	select_delay_wait_checks(mpp);
+	select_skip_kpartx(mpp);
 
 	sysfs_set_scsi_tmo(mpp);
 	/*
@@ -580,6 +581,7 @@ extern int
 domap (struct multipath * mpp)
 {
 	int r = 0;
+	uint16_t udev_flags = (mpp->skip_kpartx == SKIP_KPARTX_ON)? MPATH_UDEV_NO_KPARTX_FLAG : 0;
 
 	/*
 	 * last chance to quit before touching the devmaps
@@ -625,25 +627,27 @@ domap (struct multipath * mpp)
 	case ACT_RELOAD:
 		r = dm_addmap_reload(mpp);
 		if (r)
-			r = dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias);
+			r = dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias,
+						 udev_flags);
 		break;
 
- 	case ACT_RESIZE:
-  		r = dm_addmap_reload(mpp);
-  		if (r)
-  			r = dm_simplecmd_flush(DM_DEVICE_RESUME, mpp->alias, 1);
+	case ACT_RESIZE:
+		r = dm_addmap_reload(mpp);
+		if (r)
+			r = dm_simplecmd_flush(DM_DEVICE_RESUME, mpp->alias, 1,
+					       udev_flags);
 		break;
 
 	case ACT_RENAME:
-		r = dm_rename(mpp->alias_old, mpp->alias);
+		r = dm_rename(mpp->alias_old, mpp->alias, mpp->skip_kpartx);
 		break;
 
 	case ACT_RENAME2:
-		r = dm_rename(mpp->alias_old, mpp->alias);
+		r = dm_rename(mpp->alias_old, mpp->alias, mpp->skip_kpartx);
 		if (r) {
 			r = dm_addmap_reload(mpp);
 			if (r)
-				r = dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias);
+				r = dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias, udev_flags);
 		}
 		break;
 
Index: multipath-tools/libmultipath/devmapper.c
===================================================================
--- multipath-tools.orig/libmultipath/devmapper.c
+++ multipath-tools/libmultipath/devmapper.c
@@ -196,7 +196,7 @@ dm_prereq (void)
 }
 
 static int
-dm_simplecmd (int task, const char *name, int no_flush, int need_sync) {
+dm_simplecmd (int task, const char *name, int no_flush, int need_sync, uint16_t udev_flags) {
 	int r = 0;
 	int udev_wait_flag = (need_sync && (task == DM_DEVICE_RESUME ||
 					    task == DM_DEVICE_REMOVE));
@@ -215,7 +215,7 @@ dm_simplecmd (int task, const char *name
 		dm_task_no_flush(dmt);		/* for DM_DEVICE_SUSPEND/RESUME */
 #endif
 
-	if (udev_wait_flag && !dm_task_set_cookie(dmt, &conf->cookie, DM_UDEV_DISABLE_LIBRARY_FALLBACK))
+	if (udev_wait_flag && !dm_task_set_cookie(dmt, &conf->cookie, DM_UDEV_DISABLE_LIBRARY_FALLBACK | udev_flags))
 		goto out;
 	r = dm_task_run (dmt);
 
@@ -225,21 +225,24 @@ dm_simplecmd (int task, const char *name
 }
 
 extern int
-dm_simplecmd_flush (int task, const char *name, int needsync) {
-	return dm_simplecmd(task, name, 0, needsync);
+dm_simplecmd_flush (int task, const char *name, int needsync, uint16_t udev_flags) {
+	return dm_simplecmd(task, name, 0, needsync, udev_flags);
 }
 
 extern int
-dm_simplecmd_noflush (int task, const char *name) {
-	return dm_simplecmd(task, name, 1, 1);
+dm_simplecmd_noflush (int task, const char *name, uint16_t udev_flags) {
+	return dm_simplecmd(task, name, 1, 1, udev_flags);
 }
 
 extern int
 dm_addmap (int task, const char *target, struct multipath *mpp, int use_uuid,
-	   int ro) {
+	   int ro, int skip_kpartx) {
 	int r = 0;
 	struct dm_task *dmt;
 	char *prefixed_uuid = NULL;
+	uint16_t udev_flags = DM_UDEV_DISABLE_LIBRARY_FALLBACK |
+			      ((skip_kpartx == SKIP_KPARTX_ON)?
+			       MPATH_UDEV_NO_KPARTX_FLAG : 0);
 
 	if (!(dmt = dm_task_create (task)))
 		return 0;
@@ -278,7 +281,7 @@ dm_addmap (int task, const char *target,
 	dm_task_no_open_count(dmt);
 
 	if (task == DM_DEVICE_CREATE &&
-	    !dm_task_set_cookie(dmt, &conf->cookie, DM_UDEV_DISABLE_LIBRARY_FALLBACK))
+	    !dm_task_set_cookie(dmt, &conf->cookie, udev_flags))
 		goto freeout;
 	r = dm_task_run (dmt);
 
@@ -299,7 +302,8 @@ dm_addmap_create (struct multipath *mpp)
 	for (ro = 0; ro <= 1; ro++) {
 		int err;
 
-		if (dm_addmap(DM_DEVICE_CREATE, TGT_MPATH, mpp, 1, ro))
+		if (dm_addmap(DM_DEVICE_CREATE, TGT_MPATH,
+			      mpp, 1, ro, mpp->skip_kpartx))
 			return 1;
 		/*
 	 	 * DM_DEVICE_CREATE is actually DM_DEV_CREATE + DM_TABLE_LOAD.
@@ -321,11 +325,11 @@ dm_addmap_create (struct multipath *mpp)
 
 extern int
 dm_addmap_reload (struct multipath *mpp) {
-	if (dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RW))
+	if (dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RW, SKIP_KPARTX_OFF))
 		return 1;
 	if (errno != EROFS)
 		return 0;
-	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RO);
+	return dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ADDMAP_RO, SKIP_KPARTX_OFF);
 }
 
 extern int
@@ -597,7 +601,7 @@ _dm_flush_map (const char * mapname, int
 		return 1;
 	}
 
-	r = dm_simplecmd_flush(DM_DEVICE_REMOVE, mapname, need_sync);
+	r = dm_simplecmd_flush(DM_DEVICE_REMOVE, mapname, need_sync, 0);
 
 	if (r) {
 		condlog(4, "multipath map %s removed", mapname);
@@ -999,7 +1003,7 @@ dm_remove_partmaps (const char * mapname
 				 */
 				condlog(4, "partition map %s removed",
 					names->name);
-				dm_simplecmd_flush(DM_DEVICE_REMOVE, names->name, need_sync);
+				dm_simplecmd_flush(DM_DEVICE_REMOVE, names->name, need_sync, 0);
 		   }
 
 		next = names->next;
@@ -1120,7 +1124,7 @@ dm_rename_partmaps (char * old, char * n
 				 */
 				snprintf(buff, PARAMS_SIZE, "%s%s",
 					 new, names->name + strlen(old));
-				dm_rename(names->name, buff);
+				dm_rename(names->name, buff, SKIP_KPARTX_OFF);
 				condlog(4, "partition map %s renamed",
 					names->name);
 		   }
@@ -1136,10 +1140,13 @@ out:
 }
 
 int
-dm_rename (char * old, char * new)
+dm_rename (char * old, char * new, int skip_kpartx)
 {
 	int r = 0;
 	struct dm_task *dmt;
+	uint16_t udev_flags = DM_UDEV_DISABLE_LIBRARY_FALLBACK |
+			      ((skip_kpartx == SKIP_KPARTX_ON)?
+			       MPATH_UDEV_NO_KPARTX_FLAG : 0);
 
 	if (dm_rename_partmaps(old, new))
 		return r;
@@ -1155,7 +1162,7 @@ dm_rename (char * old, char * new)
 
 	dm_task_no_open_count(dmt);
 
-	if (!dm_task_set_cookie(dmt, &conf->cookie, DM_UDEV_DISABLE_LIBRARY_FALLBACK))
+	if (!dm_task_set_cookie(dmt, &conf->cookie, udev_flags))
 		goto out;
 	if (!dm_task_run(dmt))
 		goto out;
Index: multipath-tools/libmultipath/devmapper.h
===================================================================
--- multipath-tools.orig/libmultipath/devmapper.h
+++ multipath-tools/libmultipath/devmapper.h
@@ -6,14 +6,20 @@
 #define TGT_MPATH	"multipath"
 #define TGT_PART	"linear"
 
+#ifdef DM_SUBSYSTEM_UDEV_FLAG1
+#define MPATH_UDEV_NO_KPARTX_FLAG DM_SUBSYSTEM_UDEV_FLAG1
+#else
+#define MPATH_UDEV_NO_KPARTX_FLAG 0
+#endif
+
 void dm_init(void);
 int dm_prereq (void);
 int dm_drv_get_rq (void);
 int dm_ge_version(unsigned int t1, unsigned int t2, unsigned int t3);
-int dm_simplecmd_flush (int, const char *, int);
-int dm_simplecmd_noflush (int, const char *);
+int dm_simplecmd_flush (int, const char *, int, uint16_t);
+int dm_simplecmd_noflush (int, const char *, uint16_t);
 int dm_addmap (int task, const char *target, struct multipath *mpp,
-	       int use_uuid, int ro);
+	       int use_uuid, int ro, int skip_kpartx);
 int dm_addmap_create (struct multipath *mpp);
 int dm_addmap_reload (struct multipath *mpp);
 int dm_map_present (const char *);
@@ -38,7 +44,7 @@ char * dm_mapname(int major, int minor);
 int dm_remove_partmaps (const char * mapname, int need_sync);
 int dm_get_uuid(char *name, char *uuid);
 int dm_get_info (char * mapname, struct dm_info ** dmi);
-int dm_rename (char * old, char * new);
+int dm_rename (char * old, char * new, int skip_kpartx);
 int dm_get_name(char * uuid, char * name);
 
 #endif /* _DEVMAPPER_H */
Index: multipath-tools/multipathd/cli_handlers.c
===================================================================
--- multipath-tools.orig/multipathd/cli_handlers.c
+++ multipath-tools/multipathd/cli_handlers.c
@@ -729,7 +729,7 @@ cli_suspend(void * v, char ** reply, int
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, MAP);
-	int r = dm_simplecmd_noflush(DM_DEVICE_SUSPEND, param);
+	int r = dm_simplecmd_noflush(DM_DEVICE_SUSPEND, param, 0);
 
 	condlog(2, "%s: suspend (operator)", param);
 
@@ -750,16 +750,20 @@ cli_resume(void * v, char ** reply, int 
 {
 	struct vectors * vecs = (struct vectors *)data;
 	char * param = get_keyparam(v, MAP);
-	int r = dm_simplecmd_noflush(DM_DEVICE_RESUME, param);
-
-	condlog(2, "%s: resume (operator)", param);
+	int r;
+	struct multipath * mpp;
+	uint16_t udev_flags;
 
-	if (!r) /* error */
+	mpp = find_mp_by_alias(vecs->mpvec, param);
+	if (!mpp)
 		return 1;
 
-	struct multipath * mpp = find_mp_by_alias(vecs->mpvec, param);
+	udev_flags = (mpp->skip_kpartx)? MPATH_UDEV_NO_KPARTX_FLAG : 0;
+	r = dm_simplecmd_noflush(DM_DEVICE_RESUME, param, udev_flags);
 
-	if (!mpp)
+	condlog(2, "%s: resume (operator)", param);
+
+	if (!r) /* error */
 		return 1;
 
 	dm_get_info(param, &mpp->dmi);
Index: multipath-tools/multipathd/main.c
===================================================================
--- multipath-tools.orig/multipathd/main.c
+++ multipath-tools/multipathd/main.c
@@ -374,6 +374,7 @@ uev_check_for_rw (struct sysfs_device * 
 	struct multipath * mpp;
 	unsigned int ro;
 	char *mode;
+	uint16_t udev_flags;
 
 	condlog(3, "%s: change path (uevent)", dev->kernel);
 	pp = find_path_by_dev(vecs->pathvec, dev->kernel);
@@ -384,6 +385,7 @@ uev_check_for_rw (struct sysfs_device * 
 	 * different */
 	prio_init(&pp->prio);
 	mpp = pp->mpp;
+	udev_flags = (mpp->skip_kpartx == SKIP_KPARTX_ON)? MPATH_UDEV_NO_KPARTX_FLAG : 0;
 	if (mpp->reload_readwrite != RELOAD_RW_ON || !mpp->dmi)
 		return 0;
 	if (sysfs_get_ro(pp->sysdev, &ro)) {
@@ -397,8 +399,10 @@ uev_check_for_rw (struct sysfs_device * 
 	condlog(2, "%s: reloading map %s", mpp->alias, mode);
 	update_mpp_paths(mpp, vecs->pathvec);
 	setup_map(mpp);
-	if (dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ro) <= 0 ||
-	    dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias) <= 0) {
+	if (dm_addmap(DM_DEVICE_RELOAD, TGT_MPATH, mpp, 0, ro,
+	    mpp->skip_kpartx) <= 0 ||
+	    dm_simplecmd_noflush(DM_DEVICE_RESUME, mpp->alias,
+				 udev_flags) <= 0) {
 		condlog(0, "%s: Failed to reload map %s : %s",
 			mpp->alias, mode, strerror(errno));
 		return 1;
Index: multipath-tools/libmultipath/config.c
===================================================================
--- multipath-tools.orig/libmultipath/config.c
+++ multipath-tools/libmultipath/config.c
@@ -320,6 +320,7 @@ merge_hwe (struct hwentry * hwe1, struct
 	merge_num(reload_readwrite);
 	merge_num(delay_watch_checks);
 	merge_num(delay_wait_checks);
+	merge_num(skip_kpartx);
 
 	return 0;
 }
@@ -367,6 +368,7 @@ overwrite_hwe (struct hwentry * dst, str
 	overwrite_num(reload_readwrite);
 	overwrite_num(delay_watch_checks);
 	overwrite_num(delay_wait_checks);
+	overwrite_num(skip_kpartx);
 
 	if (dst->no_path_retry == NO_PATH_RETRY_FAIL && dst->features) {
 		char *tmp;
@@ -578,6 +580,7 @@ load_config (char * file)
 	conf->force_sync = 0;
 	conf->processed_main_config = 0;
 	conf->maps_present = 0;
+	conf->skip_kpartx = DEFAULT_SKIP_KPARTX;
 
 	/*
 	 * preload default hwtable
Index: multipath-tools/libmultipath/config.h
===================================================================
--- multipath-tools.orig/libmultipath/config.h
+++ multipath-tools/libmultipath/config.h
@@ -44,6 +44,7 @@ struct hwentry {
 	int reload_readwrite;
 	int delay_watch_checks;
 	int delay_wait_checks;
+	int skip_kpartx;
 	char * bl_product;
 };
 
@@ -68,6 +69,7 @@ struct mpentry {
 	int user_friendly_names;
 	int delay_watch_checks;
 	int delay_wait_checks;
+	int skip_kpartx;
 	uid_t uid;
 	gid_t gid;
 	mode_t mode;
@@ -119,6 +121,7 @@ struct config {
 	int delay_watch_checks;
 	int delay_wait_checks;
 	int maps_present;
+	int skip_kpartx;
 
 	char * dev;
 	char * sysfs_dir;
Index: multipath-tools/libmultipath/defaults.h
===================================================================
--- multipath-tools.orig/libmultipath/defaults.h
+++ multipath-tools/libmultipath/defaults.h
@@ -19,6 +19,7 @@
 #define DEFAULT_DETECT_PRIO DETECT_PRIO_OFF
 #define DEFAULT_RELOAD_RW RELOAD_RW_OFF
 #define DEFAULT_DELAY_CHECKS    DELAY_CHECKS_OFF
+#define DEFAULT_SKIP_KPARTX SKIP_KPARTX_OFF
 
 #define DEFAULT_CHECKINT	5
 #define MAX_CHECKINT(a)		(a << 2)
Index: multipath-tools/libmultipath/dict.c
===================================================================
--- multipath-tools.orig/libmultipath/dict.c
+++ multipath-tools/libmultipath/dict.c
@@ -786,6 +786,29 @@ def_delay_wait_checks_handler(vector str
 	return 0;
 }
 
+static int
+def_skip_kpartx_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		conf->skip_kpartx = SKIP_KPARTX_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		conf->skip_kpartx = SKIP_KPARTX_ON;
+	else
+		conf->skip_kpartx = DEFAULT_SKIP_KPARTX;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * blacklist block handlers
  */
@@ -1473,6 +1496,33 @@ hw_reload_readwrite_handler(vector strve
 }
 
 static int
+hw_skip_kpartx_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->skip_kpartx = SKIP_KPARTX_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		hwe->skip_kpartx = SKIP_KPARTX_ON;
+	else
+		hwe->skip_kpartx = SKIP_KPARTX_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
+static int
 hw_delay_watch_checks_handler(vector strvec)
 {
 	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
@@ -1952,6 +2002,32 @@ mp_reservation_key_handler (vector strve
 }
 
 static int
+mp_skip_kpartx_handler(vector strvec)
+{
+	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
+	char * buff;
+
+	if (!mpe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && strcmp(buff, "no") == 0) ||
+	    (strlen(buff) == 1 && strcmp(buff, "0") == 0))
+		mpe->skip_kpartx = SKIP_KPARTX_OFF;
+	else if ((strlen(buff) == 3 && strcmp(buff, "yes") == 0) ||
+		 (strlen(buff) == 1 && strcmp(buff, "1") == 0))
+		mpe->skip_kpartx = SKIP_KPARTX_ON;
+	else
+		mpe->skip_kpartx = SKIP_KPARTX_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
+static int
 mp_delay_watch_checks_handler(vector strvec)
 {
 	struct mpentry *mpe = VECTOR_LAST_SLOT(conf->mptable);
@@ -2223,6 +2299,19 @@ snprint_mp_reservation_key (char * buff,
 }
 
 static int
+snprint_mp_skip_kpartx (char * buff, int len, void * data)
+{
+	struct mpentry * mpe = (struct mpentry *)data;
+
+	if (mpe->skip_kpartx == SKIP_KPARTX_UNDEF)
+		return 0;
+	else if (mpe->skip_kpartx == SKIP_KPARTX_OFF)
+		return snprintf(buff, len, "no");
+	else
+		return snprintf(buff, len, "yes");
+}
+
+static int
 snprint_mp_delay_watch_checks(char * buff, int len, void * data)
 {
 	struct mpentry * mpe = (struct mpentry *)data;
@@ -2565,6 +2654,19 @@ snprint_hw_reload_readwrite(char *buff, 
 }
 
 static int
+snprint_hw_skip_kpartx(char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->skip_kpartx == SKIP_KPARTX_ON)
+		return snprintf(buff, len, "yes");
+	else if (hwe->skip_kpartx == SKIP_KPARTX_OFF)
+		return snprintf(buff, len, "no");
+	else
+		return 0;
+}
+
+static int
 snprint_hw_delay_watch_checks(char * buff, int len, void * data)
 {
 	struct hwentry * hwe = (struct hwentry *)data;
@@ -2973,6 +3075,15 @@ snprint_def_delay_wait_checks(char * buf
 }
 
 static int
+snprint_def_skip_kpartx(char * buff, int len, void * data)
+{
+	if (conf->skip_kpartx == SKIP_KPARTX_ON)
+		return snprintf(buff, len, "yes");
+	else
+		return snprintf(buff, len, "no");
+}
+
+static int
 snprint_ble_simple (char * buff, int len, void * data)
 {
 	struct blentry * ble = (struct blentry *)data;
@@ -3035,6 +3146,7 @@ init_keywords(void)
 	install_keyword("reload_readwrite", &def_reload_readwrite_handler, &snprint_def_reload_readwrite);
 	install_keyword("replace_wwid_whitespace", &def_replace_wwid_whitespace_handler, &snprint_def_replace_wwid_whitespace);
 	install_keyword("force_sync", &def_force_sync_handler, &snprint_def_force_sync);
+	install_keyword("skip_kpartx", &def_skip_kpartx_handler, &snprint_def_skip_kpartx);
 	install_keyword("config_dir", &def_config_dir_handler, &snprint_def_config_dir);
 	install_keyword("delay_watch_checks", &def_delay_watch_checks_handler, &snprint_def_delay_watch_checks);
 	install_keyword("delay_wait_checks", &def_delay_wait_checks_handler, &snprint_def_delay_wait_checks);
@@ -3106,6 +3218,7 @@ init_keywords(void)
 	install_keyword("reload_readwrite", &hw_reload_readwrite_handler, &snprint_hw_reload_readwrite);
 	install_keyword("delay_watch_checks", &hw_delay_watch_checks_handler, &snprint_hw_delay_watch_checks);
 	install_keyword("delay_wait_checks", &hw_delay_wait_checks_handler, &snprint_hw_delay_wait_checks);
+	install_keyword("skip_kpartx", &hw_skip_kpartx_handler, &snprint_hw_skip_kpartx);
 	install_sublevel_end();
 
 	install_keyword_root("multipaths", &multipaths_handler);
@@ -3130,5 +3243,6 @@ init_keywords(void)
 	install_keyword("reservation_key", &mp_reservation_key_handler, &snprint_mp_reservation_key);
 	install_keyword("delay_watch_checks", &mp_delay_watch_checks_handler, &snprint_mp_delay_watch_checks);
 	install_keyword("delay_wait_checks", &mp_delay_wait_checks_handler, &snprint_mp_delay_wait_checks);
+	install_keyword("skip_kpartx", &mp_skip_kpartx_handler, &snprint_mp_skip_kpartx);
 	install_sublevel_end();
 }
Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -755,3 +755,29 @@ select_delay_wait_checks (struct multipa
 	condlog(3, "delay_wait_checks = DISABLED (internal default)");
 	return 0;
 }
+
+extern int
+select_skip_kpartx (struct multipath * mp)
+{
+	if (mp->mpe && mp->mpe->skip_kpartx != SKIP_KPARTX_UNDEF) {
+		mp->skip_kpartx = mp->mpe->skip_kpartx;
+		condlog(3, "skip_kpartx = %i (multipath setting)",
+				mp->skip_kpartx);
+		return 0;
+	}
+	if (mp->hwe && mp->hwe->skip_kpartx != SKIP_KPARTX_UNDEF) {
+		mp->skip_kpartx = mp->hwe->skip_kpartx;
+		condlog(3, "skip_kpartx = %i (controler setting)",
+				mp->skip_kpartx);
+		return 0;
+	}
+	if (conf->skip_kpartx != SKIP_KPARTX_UNDEF) {
+		mp->skip_kpartx = conf->skip_kpartx;
+		condlog(3, "skip_kpartx = %i (config file default)",
+				mp->skip_kpartx);
+		return 0;
+	}
+	mp->skip_kpartx = DEFAULT_SKIP_KPARTX;
+	condlog(3, "skip_kpartx = DISABLED (internal default)");
+	return 0;
+}
Index: multipath-tools/libmultipath/propsel.h
===================================================================
--- multipath-tools.orig/libmultipath/propsel.h
+++ multipath-tools/libmultipath/propsel.h
@@ -23,3 +23,4 @@ int select_detect_prio(struct path * pp)
 int select_reload_readwrite (struct multipath * mp);
 int select_delay_watch_checks (struct multipath * mp);
 int select_delay_wait_checks (struct multipath * mp);
+int select_skip_kpartx (struct multipath * mp);
Index: multipath-tools/libmultipath/structs.h
===================================================================
--- multipath-tools.orig/libmultipath/structs.h
+++ multipath-tools/libmultipath/structs.h
@@ -131,6 +131,12 @@ struct scsi_idlun {
 };
 
 
+enum skip_kpartx_states {
+	SKIP_KPARTX_UNDEF,
+	SKIP_KPARTX_OFF,
+	SKIP_KPARTX_ON,
+};
+
 enum scsi_protocol {
 	SCSI_PROTOCOL_UNSPEC,
 	SCSI_PROTOCOL_FCP,
@@ -227,6 +233,7 @@ struct multipath {
 	int reload_readwrite;
 	int delay_watch_checks;
 	int delay_wait_checks;
+	int skip_kpartx;
 	unsigned int dev_loss;
 	uid_t uid;
 	gid_t gid;
Index: multipath-tools/multipath/multipath.conf.5
===================================================================
--- multipath-tools.orig/multipath/multipath.conf.5
+++ multipath-tools/multipath/multipath.conf.5
@@ -470,6 +470,12 @@ used until it has passed
 .I delay_wait_checks
 checks. Default is
 .I no
+.TP
+.B skip_kpartx
+If set to
+.I yes
+, kpartx will not automatically create partitions on the device. The default is
+.I no
 .
 .SH "blacklist section"
 The
@@ -569,6 +575,8 @@ section:
 .B delay_watch_checks
 .TP
 .B delay_wait_checks
+.TP
+.B skip_kpartx
 .RE
 .PD
 .LP
@@ -658,6 +666,8 @@ section:
 .B delay_watch_checks
 .TP
 .B delay_wait_checks
+.TP
+.B skip_kpartx
 .RE
 .PD
 .LP
Index: multipath-tools/multipath/multipath.rules
===================================================================
--- multipath-tools.orig/multipath/multipath.rules
+++ multipath-tools/multipath/multipath.rules
@@ -18,6 +18,7 @@ KERNEL!="dm-*", GOTO="end_mpath"
 ENV{DM_UUID}=="mpath-?*|part[0-9]*-mpath-?*", OPTIONS+="link_priority=10"
 ACTION!="change", GOTO="end_mpath"
 ENV{DM_UUID}!="mpath-?*", GOTO="end_mpath"
+ENV{DM_SUBSYSTEM_UDEV_FLAG1}=="1", GOTO="end_mpath"
 ENV{DM_SUSPENDED}=="1", GOTO="end_mpath"
 ENV{DM_ACTION}=="PATH_FAILED", GOTO="end_mpath"
 ENV{DM_ACTIVATION}=="1", RUN+="$env{MPATH_SBIN_PATH}/kpartx -an -p p $tempnode"
