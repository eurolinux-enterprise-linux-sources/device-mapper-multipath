---
 libmultipath/config.c      |    5 +++-
 libmultipath/config.h      |    1 
 libmultipath/configure.c   |    1 
 libmultipath/defaults.h    |    1 
 libmultipath/dict.c        |   48 +++++++++++++++++++++++++++++++++++++++++----
 libmultipath/hwtable.c     |    1 
 libmultipath/propsel.c     |   21 +++++++++++++++++++
 libmultipath/propsel.h     |    1 
 libmultipath/structs.h     |    7 ++++++
 libmultipath/structs_vec.c |    1 
 multipath.conf.annotated   |   13 ++++++++++++
 multipath.conf.defaults    |    1 
 multipath/multipath.conf.5 |    2 +
 multipathd/main.c          |    5 ++--
 14 files changed, 101 insertions(+), 7 deletions(-)

Index: multipath-tools/libmultipath/config.c
===================================================================
--- multipath-tools.orig/libmultipath/config.c
+++ multipath-tools/libmultipath/config.c
@@ -317,6 +317,7 @@ merge_hwe (struct hwentry * hwe1, struct
 	merge_num(user_friendly_names);
 	merge_num(retain_hwhandler);
 	merge_num(detect_prio);
+	merge_num(reload_readwrite);
 
 	return 0;
 }
@@ -361,6 +362,7 @@ overwrite_hwe (struct hwentry * dst, str
 	overwrite_num(user_friendly_names);
 	overwrite_num(retain_hwhandler);
 	overwrite_num(detect_prio);
+	overwrite_num(reload_readwrite);
 
 	if (dst->no_path_retry == NO_PATH_RETRY_FAIL && dst->features) {
 		char *tmp;
@@ -430,6 +432,7 @@ store_hwe (vector hwtable, struct hwentr
 	hwe->user_friendly_names = dhwe->user_friendly_names;
 	hwe->retain_hwhandler = dhwe->retain_hwhandler;
 	hwe->detect_prio = dhwe->detect_prio;
+	hwe->reload_readwrite = dhwe->reload_readwrite;
 
 	if (dhwe->bl_product && !(hwe->bl_product = set_param_str(dhwe->bl_product)))
 		goto out;
@@ -559,7 +562,7 @@ load_config (char * file)
 	conf->find_multipaths = DEFAULT_FIND_MULTIPATHS;
 	conf->retain_hwhandler = DEFAULT_RETAIN_HWHANDLER;
 	conf->detect_prio = DEFAULT_DETECT_PRIO;
-	conf->reload_readwrite = 0;
+	conf->reload_readwrite = DEFAULT_RELOAD_RW;
 	conf->replace_wwid_whitespace = 0;
 
 	/*
Index: multipath-tools/libmultipath/config.h
===================================================================
--- multipath-tools.orig/libmultipath/config.h
+++ multipath-tools/libmultipath/config.h
@@ -41,6 +41,7 @@ struct hwentry {
 	int user_friendly_names;
 	int retain_hwhandler;
 	int detect_prio;
+	int reload_readwrite;
 	char * bl_product;
 };
 
Index: multipath-tools/libmultipath/configure.c
===================================================================
--- multipath-tools.orig/libmultipath/configure.c
+++ multipath-tools/libmultipath/configure.c
@@ -76,6 +76,7 @@ setup_map (struct multipath * mpp)
 	select_dev_loss(mpp);
 	select_reservation_key(mpp);
 	select_retain_hwhandler(mpp);
+	select_reload_readwrite(mpp);
 
 	sysfs_set_scsi_tmo(mpp);
 	/*
Index: multipath-tools/libmultipath/defaults.h
===================================================================
--- multipath-tools.orig/libmultipath/defaults.h
+++ multipath-tools/libmultipath/defaults.h
@@ -17,6 +17,7 @@
 #define DEFAULT_FIND_MULTIPATHS 0
 #define DEFAULT_RETAIN_HWHANDLER RETAIN_HWHANDLER_OFF
 #define DEFAULT_DETECT_PRIO DETECT_PRIO_OFF
+#define DEFAULT_RELOAD_RW RELOAD_RW_OFF
 
 #define DEFAULT_CHECKINT	5
 #define MAX_CHECKINT(a)		(a << 2)
Index: multipath-tools/libmultipath/dict.c
===================================================================
--- multipath-tools.orig/libmultipath/dict.c
+++ multipath-tools/libmultipath/dict.c
@@ -677,12 +677,12 @@ def_reload_readwrite_handler(vector strv
 
 	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
 	    (strlen(buff) == 1 && !strcmp(buff, "0")))
-		conf->reload_readwrite = 0;
+		conf->reload_readwrite = RELOAD_RW_OFF;
 	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
 		 (strlen(buff) == 1 && !strcmp(buff, "1")))
-		conf->reload_readwrite = 1;
+		conf->reload_readwrite = RELOAD_RW_ON;
 	else
-		conf->reload_readwrite = 0;
+		conf->reload_readwrite = DEFAULT_RELOAD_RW;
 
 	FREE(buff);
 	return 0;
@@ -1389,6 +1389,32 @@ hw_detect_prio_handler(vector strvec)
 	return 0;
 }
 
+
+static int
+hw_reload_readwrite_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+	if (!buff)
+		return 1;
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->reload_readwrite = RELOAD_RW_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		hwe->reload_readwrite = RELOAD_RW_ON;
+	else
+		hwe->reload_readwrite = RELOAD_RW_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * multipaths block handlers
  */
@@ -2399,6 +2425,19 @@ snprint_detect_prio(char * buff, int len
 }
 
 static int
+snprint_hw_reload_readwrite(char *buff, int len, void *data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->reload_readwrite == RELOAD_RW_ON)
+		return snprintf(buff, len, "yes");
+	else if (hwe->reload_readwrite == RELOAD_RW_OFF)
+		return snprintf(buff, len, "no");
+	else
+		return 0;
+}
+
+static int
 snprint_def_polling_interval (char * buff, int len, void * data)
 {
 	return snprintf(buff, len, "%i", conf->checkint);
@@ -2737,7 +2776,7 @@ snprint_def_detect_prio(char * buff, int
 static int
 snprint_def_reload_readwrite(char * buff, int len, void * data)
 {
-	if (conf->reload_readwrite)
+	if (conf->reload_readwrite == RELOAD_RW_ON)
 		return snprintf(buff, len, "yes");
 	else
 		return snprintf(buff, len, "no");
@@ -2879,6 +2918,7 @@ init_keywords(void)
 	install_keyword("user_friendly_names", &hw_names_handler, &snprint_hw_user_friendly_names);
 	install_keyword("retain_attached_hw_handler", &hw_retain_hwhandler_handler, &snprint_hw_retain_hwhandler);
 	install_keyword("detect_prio", &hw_detect_prio_handler, &snprint_detect_prio);
+	install_keyword("reload_readwrite", &hw_reload_readwrite_handler, &snprint_hw_reload_readwrite);
 	install_sublevel_end();
 
 	install_keyword_root("multipaths", &multipaths_handler);
Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -670,3 +670,24 @@ select_detect_prio (struct path * pp)
 	condlog(3, "%s: detect_prio = %d (compiled in default)", pp->dev, pp->detect_prio);
 	return 0;
 }
+
+extern int
+select_reload_readwrite (struct multipath * mp)
+{
+	if (mp->hwe && mp->hwe->reload_readwrite) {
+		mp->reload_readwrite = mp->hwe->reload_readwrite;
+		condlog(3, "%s: reload_readwrite = %d (controller default)",
+			mp->alias, mp->reload_readwrite);
+		return 0;
+	}
+	if (conf->reload_readwrite) {
+		mp->reload_readwrite = conf->reload_readwrite;
+		condlog(3, "%s: reload_readwrite = %d (config file default)",
+			mp->alias, mp->reload_readwrite);
+		return 0;
+	}
+	mp->reload_readwrite = DEFAULT_RELOAD_RW;
+	condlog(3, "%s: reload_readwrite = %d (compiled in default)",
+		mp->alias, mp->reload_readwrite);
+	return 0;
+}
Index: multipath-tools/libmultipath/propsel.h
===================================================================
--- multipath-tools.orig/libmultipath/propsel.h
+++ multipath-tools/libmultipath/propsel.h
@@ -20,3 +20,4 @@ int select_dev_loss(struct multipath *mp
 int select_reservation_key(struct multipath *mp);
 int select_retain_hwhandler (struct multipath * mp);
 int select_detect_prio(struct path * pp);
+int select_reload_readwrite (struct multipath * mp);
Index: multipath-tools/libmultipath/structs.h
===================================================================
--- multipath-tools.orig/libmultipath/structs.h
+++ multipath-tools/libmultipath/structs.h
@@ -113,6 +113,12 @@ enum detect_prio_states {
 	DETECT_PRIO_ON,
 };
 
+enum reload_readwrite_states {
+	RELOAD_RW_UNDEF,
+	RELOAD_RW_OFF,
+	RELOAD_RW_ON,
+};
+
 struct scsi_idlun {
 	int dev_id;
 	int host_unique_id;
@@ -204,6 +210,7 @@ struct multipath {
 	int attribute_flags;
 	int fast_io_fail;
 	int retain_hwhandler;
+	int reload_readwrite;
 	unsigned int dev_loss;
 	uid_t uid;
 	gid_t gid;
Index: multipath-tools/multipathd/main.c
===================================================================
--- multipath-tools.orig/multipathd/main.c
+++ multipath-tools/multipathd/main.c
@@ -372,7 +372,8 @@ uev_check_for_rw (struct sysfs_device * 
 	if (!pp || !pp->mpp) /* not a multipath path device */
 		return 0;
 	mpp = pp->mpp;
-	if (!mpp->dmi || !mpp->dmi->read_only)
+	if (mpp->reload_readwrite != RELOAD_RW_ON || !mpp->dmi ||
+	    !mpp->dmi->read_only)
 		return 0;
 	if (sysfs_get_ro(pp->sysdev, &ro)) {
 		condlog(2, "%s: unable to get readonly status", dev->kernel);
@@ -801,7 +802,7 @@ uev_trigger (struct uevent * uev, void *
 		r = uev_remove_path(sysdev, vecs);
 		goto out;
 	}
-	if (!strncmp(uev->action, "change", 6) && conf->reload_readwrite) {
+	if (!strncmp(uev->action, "change", 6)) {
 		r = uev_check_for_rw(sysdev, vecs);
 		goto out;
 	}
Index: multipath-tools/libmultipath/hwtable.c
===================================================================
--- multipath-tools.orig/libmultipath/hwtable.c
+++ multipath-tools/libmultipath/hwtable.c
@@ -989,6 +989,7 @@ static struct hwentry default_hw[] = {
 		.prio_name     = PRIO_ONTAP,
 		.retain_hwhandler = RETAIN_HWHANDLER_ON,
 		.detect_prio   = DETECT_PRIO_ON,
+		.reload_readwrite = RELOAD_RW_ON,
 	},
 	/*
 	 * IBM NSeries (NETAPP) controller family
Index: multipath-tools/libmultipath/structs_vec.c
===================================================================
--- multipath-tools.orig/libmultipath/structs_vec.c
+++ multipath-tools/libmultipath/structs_vec.c
@@ -377,6 +377,7 @@ retry:
 		set_no_path_retry(mpp);
 		select_pg_timeout(mpp);
 		select_flush_on_last_del(mpp);
+		select_reload_readwrite(mpp);
 	}
 
 	return 0;
Index: multipath-tools/multipath.conf.annotated
===================================================================
--- multipath-tools.orig/multipath.conf.annotated
+++ multipath-tools/multipath.conf.annotated
@@ -592,6 +592,19 @@
 #		#           before removing it from the system.
 #		# values  : n > 0
 #		dev_loss_tmo 600
+#
+#		#
+#		# name    : reload_readwrite
+#		# scope   : multipathd
+#		# desc    : If set to yes, multipathd will monitor change events
+#		#           on path devices.  When it receives a change event
+#		#           for a path of a readonly multipath device, it will
+#		#           check if the path is now read/write.  If so,
+#		#           multipathd will reload the multipath device to
+#		#           switch it to read/write.
+#		# values  : yes|no
+#		reload_readwrite yes
+#
 #	}
 #	device {
 #		vendor			"COMPAQ  "
Index: multipath-tools/multipath.conf.defaults
===================================================================
--- multipath-tools.orig/multipath.conf.defaults
+++ multipath-tools/multipath.conf.defaults
@@ -916,6 +916,7 @@
 #		dev_loss_tmo infinity
 #		retain_attached_hw_handler yes
 #		detect_prio yes
+#		reload_readwrite yes
 #	}
 #	device {
 #		vendor "IBM"
Index: multipath-tools/multipath/multipath.conf.5
===================================================================
--- multipath-tools.orig/multipath/multipath.conf.5
+++ multipath-tools/multipath/multipath.conf.5
@@ -596,6 +596,8 @@ section:
 .B retain_attached_hw_handler
 .TP
 .B detect_prio
+.TP
+.B reload_readwrite
 .RE
 .PD
 .LP
