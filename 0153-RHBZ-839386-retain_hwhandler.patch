---
 libmultipath/config.c      |    3 +
 libmultipath/config.h      |    2 
 libmultipath/configure.c   |    7 ++
 libmultipath/defaults.h    |    1 
 libmultipath/dict.c        |   74 ++++++++++++++++++++++++++++++
 libmultipath/dmparser.c    |  108 +++++++++++++++++++++++++--------------------
 libmultipath/propsel.c     |   17 +++++++
 libmultipath/propsel.h     |    1 
 libmultipath/structs.h     |    7 ++
 multipath/multipath.conf.5 |   11 ++++
 10 files changed, 182 insertions(+), 49 deletions(-)

Index: multipath-tools/libmultipath/config.c
===================================================================
--- multipath-tools.orig/libmultipath/config.c
+++ multipath-tools/libmultipath/config.c
@@ -312,6 +312,7 @@ merge_hwe (struct hwentry * hwe1, struct
 	merge_num(fast_io_fail);
 	merge_num(dev_loss);
 	merge_num(user_friendly_names);
+	merge_num(retain_hwhandler);
 
 	return 0;
 }
@@ -365,6 +366,7 @@ store_hwe (vector hwtable, struct hwentr
 	hwe->fast_io_fail = dhwe->fast_io_fail;
 	hwe->dev_loss = dhwe->dev_loss;
 	hwe->user_friendly_names = dhwe->user_friendly_names;
+	hwe->retain_hwhandler = dhwe->retain_hwhandler;
 
 	if (dhwe->bl_product && !(hwe->bl_product = set_param_str(dhwe->bl_product)))
 		goto out;
@@ -488,6 +490,7 @@ load_config (char * file)
 	conf->flush_on_last_del = 0;
 	conf->attribute_flags = 0;
 	conf->find_multipaths = DEFAULT_FIND_MULTIPATHS;
+	conf->retain_hwhandler = DEFAULT_RETAIN_HWHANDLER;
 
 	/*
 	 * preload default hwtable
Index: multipath-tools/libmultipath/config.h
===================================================================
--- multipath-tools.orig/libmultipath/config.h
+++ multipath-tools/libmultipath/config.h
@@ -38,6 +38,7 @@ struct hwentry {
 	int fast_io_fail;
 	unsigned int dev_loss;
 	int user_friendly_names;
+	int retain_hwhandler;
 	char * bl_product;
 };
 
@@ -102,6 +103,7 @@ struct config {
 	gid_t gid;
 	mode_t mode;
 	uint32_t cookie;
+	int retain_hwhandler;
 
 	char * dev;
 	char * sysfs_dir;
Index: multipath-tools/libmultipath/defaults.h
===================================================================
--- multipath-tools.orig/libmultipath/defaults.h
+++ multipath-tools/libmultipath/defaults.h
@@ -14,6 +14,7 @@
 #define DEFAULT_USER_FRIENDLY_NAMES    0
 #define DEFAULT_VERBOSITY	2
 #define DEFAULT_FIND_MULTIPATHS 0
+#define DEFAULT_RETAIN_HWHANDLER RETAIN_HWHANDLER_OFF
 
 #define DEFAULT_CHECKINT	5
 #define MAX_CHECKINT(a)		(a << 2)
Index: multipath-tools/libmultipath/dict.c
===================================================================
--- multipath-tools.orig/libmultipath/dict.c
+++ multipath-tools/libmultipath/dict.c
@@ -619,6 +619,29 @@ def_names_handler(vector strvec)
 	return 0;
 }
 
+static int
+def_retain_hwhandler_handler(vector strvec)
+{
+	char * buff;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		conf->retain_hwhandler = RETAIN_HWHANDLER_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		conf->retain_hwhandler = RETAIN_HWHANDLER_ON;
+	else
+		conf->retain_hwhandler = RETAIN_HWHANDLER_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * blacklist block handlers
  */
@@ -1217,6 +1240,33 @@ hw_names_handler(vector strvec)
 	return 0;
 }
 
+static int
+hw_retain_hwhandler_handler(vector strvec)
+{
+	struct hwentry *hwe = VECTOR_LAST_SLOT(conf->hwtable);
+	char * buff;
+
+	if (!hwe)
+		return 1;
+
+	buff = set_value(strvec);
+
+	if (!buff)
+		return 1;
+
+	if ((strlen(buff) == 2 && !strcmp(buff, "no")) ||
+	    (strlen(buff) == 1 && !strcmp(buff, "0")))
+		hwe->retain_hwhandler = RETAIN_HWHANDLER_OFF;
+	else if ((strlen(buff) == 3 && !strcmp(buff, "yes")) ||
+		 (strlen(buff) == 1 && !strcmp(buff, "1")))
+		hwe->retain_hwhandler = RETAIN_HWHANDLER_ON;
+	else
+		hwe->retain_hwhandler = RETAIN_HWHANDLER_UNDEF;
+
+	FREE(buff);
+	return 0;
+}
+
 /*
  * multipaths block handlers
  */
@@ -2176,6 +2226,19 @@ snprint_hw_user_friendly_names (char * b
 }
 
 static int
+snprint_hw_retain_hwhandler(char * buff, int len, void * data)
+{
+	struct hwentry * hwe = (struct hwentry *)data;
+
+	if (hwe->retain_hwhandler == RETAIN_HWHANDLER_ON)
+		return snprintf(buff, len, "yes");
+	else if (hwe->retain_hwhandler == RETAIN_HWHANDLER_OFF)
+		return snprintf(buff, len, "no");
+	else
+		return 0;
+}
+
+static int
 snprint_def_polling_interval (char * buff, int len, void * data)
 {
 	return snprintf(buff, len, "%i", conf->checkint);
@@ -2481,6 +2544,15 @@ snprint_def_reservation_key(char * buff,
 }
 
 static int
+snprint_def_retain_hwhandler(char * buff, int len, void * data)
+{
+	if (conf->retain_hwhandler == RETAIN_HWHANDLER_ON)
+		return snprintf(buff, len, "yes");
+	else
+		return snprintf(buff, len, "no");
+}
+
+static int
 snprint_ble_simple (char * buff, int len, void * data)
 {
 	struct blentry * ble = (struct blentry *)data;
@@ -2538,6 +2610,7 @@ init_keywords(void)
 	install_keyword("find_multipaths", &def_find_multipaths_handler, &snprint_def_find_multipaths);
 	install_keyword("log_checker_err", &def_log_checker_err_handler, &snprint_def_log_checker_err);
 	install_keyword("reservation_key", &def_reservation_key_handler, &snprint_def_reservation_key);
+	install_keyword("retain_attached_hw_handler", &def_retain_hwhandler_handler, &snprint_def_retain_hwhandler);
 	__deprecated install_keyword("mode", &def_mode_handler, &snprint_def_mode);
 	__deprecated install_keyword("uid", &def_uid_handler, &snprint_def_uid);
 	__deprecated install_keyword("gid", &def_gid_handler, &snprint_def_gid);
@@ -2600,6 +2673,7 @@ init_keywords(void)
 	install_keyword("fast_io_fail_tmo", &hw_fast_io_fail_handler, &snprint_hw_fast_io_fail);
 	install_keyword("dev_loss_tmo", &hw_dev_loss_handler, &snprint_hw_dev_loss);
 	install_keyword("user_friendly_names", &hw_names_handler, &snprint_hw_user_friendly_names);
+	install_keyword("retain_attached_hw_handler", &hw_retain_hwhandler_handler, &snprint_hw_retain_hwhandler);
 	install_sublevel_end();
 
 	install_keyword_root("multipaths", &multipaths_handler);
Index: multipath-tools/libmultipath/structs.h
===================================================================
--- multipath-tools.orig/libmultipath/structs.h
+++ multipath-tools/libmultipath/structs.h
@@ -100,6 +100,12 @@ enum user_friendly_names_states {
 	USER_FRIENDLY_NAMES_ON,
 };
 
+enum retain_hwhandler_states {
+	RETAIN_HWHANDLER_UNDEF,
+	RETAIN_HWHANDLER_OFF,
+	RETAIN_HWHANDLER_ON,
+};
+
 struct scsi_idlun {
 	int dev_id;
 	int host_unique_id;
@@ -188,6 +194,7 @@ struct multipath {
 	int flush_on_last_del;
 	int attribute_flags;
 	int fast_io_fail;
+	int retain_hwhandler;
 	unsigned int dev_loss;
 	uid_t uid;
 	gid_t gid;
Index: multipath-tools/libmultipath/configure.c
===================================================================
--- multipath-tools.orig/libmultipath/configure.c
+++ multipath-tools/libmultipath/configure.c
@@ -75,6 +75,7 @@ setup_map (struct multipath * mpp)
 	select_fast_io_fail(mpp);
 	select_dev_loss(mpp);
 	select_reservation_key(mpp);
+	select_retain_hwhandler(mpp);
 
 	sysfs_set_scsi_tmo(mpp);
 	/*
@@ -207,8 +208,10 @@ select_action (struct multipath * mpp, v
 			mpp->alias);
 		return;
 	}
-	if (!cmpp->selector || strncmp(cmpp->hwhandler, mpp->hwhandler,
-		    strlen(mpp->hwhandler))) {
+	if (mpp->retain_hwhandler != RETAIN_HWHANDLER_ON &&
+            (strlen(cmpp->hwhandler) != strlen(mpp->hwhandler) ||
+	     strncmp(cmpp->hwhandler, mpp->hwhandler,
+		    strlen(mpp->hwhandler)))) {
 		mpp->action = ACT_RELOAD;
 		condlog(3, "%s: set ACT_RELOAD (hwhandler change)",
 			mpp->alias);
Index: multipath-tools/libmultipath/dmparser.c
===================================================================
--- multipath-tools.orig/libmultipath/dmparser.c
+++ multipath-tools/libmultipath/dmparser.c
@@ -45,73 +45,87 @@ merge_words (char ** dst, char * word, i
 	return 0;
 }
 
-char *
-remove_queue_feature (char *buf, char *features)
+int
+remove_feature (char *features, char *old)
 {
-	unsigned int count;
+	char str[PARAMS_SIZE];
+	unsigned int nr_features;
 	char *ptr, *start;
 
-	if (strlen(buf) >= PARAMS_SIZE)
-		return buf;
-	ptr = strstr(buf, "queue_if_no_path");
-	/* ptr + 16 == ptr + strlen(ptr) */
-	if (!ptr || *(ptr - 1) != ' ' ||
-            (*(ptr + 16) != ' ' && *(ptr + 16) != '\0'))
-		return buf;
-
-	count = strtoul(buf, &start, 10);
-	if (start == buf)
-		return buf;
-	if (count <= 1)
-		return "0";
+	ptr = strstr(features, old);
+	if (!ptr)
+		return 0;
+
+	nr_features = strtoul(features, &start, 10);
+	if (start == features) {
+		fprintf(stderr, "can't find number of features\n");
+		return -1;
+	}
+	if (nr_features <= 1) {
+		strcpy(features, "0");
+		return 0;
+	}
 
-	sprintf(features, "%u", count - 1);
+	sprintf(str, "%u", nr_features - 1);
 
 	if (start < ptr - 1)
-		strncat(features, start, (ptr - 1) - start);
+		strncat(str, start, (ptr - 1) - start);
 
-	ptr += 16;  /* strlen("queue_if_no_path") */
+	ptr += strlen(old);
 	if (*ptr != '\0')
-		strcat(features, ptr);
-	return features;
+		strcat(str, ptr);
+
+	strcpy(features, str);
+	return 0;
 }
 
-char *
-assemble_features (struct multipath *mp)
+int
+add_feature (char *features, char *new)
 {
-	static char features[PARAMS_SIZE];
+	char str[PARAMS_SIZE];
 	unsigned int nr_features;
-	char *ptr;
+	char *start;
 
-	if (!conf->daemon)
-		return mp->features;
-	if (mp->flush_on_last_del == FLUSH_IN_PROGRESS &&
-	    strstr(mp->features, "queue_if_no_path"))
-		return remove_queue_feature(mp->features, features);
-	if (mp->no_path_retry == NO_PATH_RETRY_UNDEF ||
-	    mp->no_path_retry == NO_PATH_RETRY_FAIL ||
-	    strstr(mp->features, "queue_if_no_path"))
-		return mp->features;
-	if (18 > PARAMS_SIZE - 1 - strlen(mp->features)) {
+	if (strstr(features, new))
+		return 0;
+
+	/* 3 = space + newline + possible increase in features_nr size */
+	if (strlen(features) + strlen(new) + 3 > PARAMS_SIZE) {
 		fprintf(stderr, "not enough size to modify features\n");
-		return mp->features;
+		return -1;
 	}
-	if (sscanf(mp->features, "%u", &nr_features) != 1) {
+	nr_features = strtoul(features, &start, 10);
+	if (features == start) {
 		fprintf(stderr, "can't find number of features\n");
-		return mp->features;
+		return -1;
 	}
-	ptr = mp->features;
-	while (isspace(*ptr))
-		ptr++;
-	if (*ptr == '\0') {
-		fprintf(stderr, "features is empty\n");
+
+	snprintf(str, PARAMS_SIZE, "%u%s %s",
+		 nr_features + 1, start, new);
+	strcpy(features, str);
+	return 0;
+}
+
+char *
+assemble_features (struct multipath *mp)
+{
+	static char features[PARAMS_SIZE];
+
+	if (strlen(mp->features) >= PARAMS_SIZE) {
+		fprintf(stderr, "not enough space to copy features\n");
 		return mp->features;
 	}
-	while(*ptr != '\0' && !isspace(*ptr))
-		ptr++;
+	strcpy(features, mp->features);
+	if (conf->daemon) {
+		if (mp->flush_on_last_del == FLUSH_IN_PROGRESS)
+			remove_feature(features, "queue_if_no_path");
+		else if (mp->no_path_retry != NO_PATH_RETRY_UNDEF &&
+			 mp->no_path_retry != NO_PATH_RETRY_FAIL)
+			add_feature(features, "queue_if_no_path");
+	}
+	if (mp->retain_hwhandler == RETAIN_HWHANDLER_ON)
+		add_feature(features, "retain_attached_hw_handler");
 
-	snprintf(features, PARAMS_SIZE, "%u%s queue_if_no_path",
-		 nr_features + 1, ptr);
 	return features;
 }
 
Index: multipath-tools/libmultipath/propsel.c
===================================================================
--- multipath-tools.orig/libmultipath/propsel.c
+++ multipath-tools/libmultipath/propsel.c
@@ -609,3 +609,20 @@ select_reservation_key (struct multipath
 	return 0;
 }
 
+extern int
+select_retain_hwhandler (struct multipath * mp)
+{
+	if (mp->hwe && mp->hwe->retain_hwhandler) {
+		mp->retain_hwhandler = mp->hwe->retain_hwhandler;
+		condlog(3, "%s: retain_attached_hw_handler = %d (controller default)", mp->alias, mp->retain_hwhandler);
+		return 0;
+	}
+	if (conf->retain_hwhandler) {
+		mp->retain_hwhandler = conf->retain_hwhandler;
+		condlog(3, "%s: retain_attached_hw_handler = %d (config file default)", mp->alias, mp->retain_hwhandler);
+		return 0;
+	}
+	mp->retain_hwhandler = 0;
+	condlog(3, "%s: retain_attached_hw_handler = %d (compiled in default)", mp->alias, mp->retain_hwhandler);
+	return 0;
+}
Index: multipath-tools/libmultipath/propsel.h
===================================================================
--- multipath-tools.orig/libmultipath/propsel.h
+++ multipath-tools/libmultipath/propsel.h
@@ -18,3 +18,4 @@ int select_gid(struct multipath *mp);
 int select_fast_io_fail(struct multipath *mp);
 int select_dev_loss(struct multipath *mp);
 int select_reservation_key(struct multipath *mp);
+int select_retain_hwhandler (struct multipath * mp);
Index: multipath-tools/multipath/multipath.conf.5
===================================================================
--- multipath-tools.orig/multipath/multipath.conf.5
+++ multipath-tools/multipath/multipath.conf.5
@@ -384,6 +384,15 @@ set for all multipath devices using pers
 the same as the RESERVATION KEY field of the PERSISTENT RESERVE OUT parameter
 list which contains an 8-byte value provided by the application client to the
 device server to identify the I_T nexus. It is unset by default.
+.TP
+.B retain_attached_hw_handler
+If set to
+.I yes
+and the scsi layer has already attached a hardware_handler to the device,
+multipath will not force the device to use the hardware_handler specified by
+mutipath.conf. If the scsi layer has not attached a hardware handler,
+multipath will continue to use its configured hardware handler. Default is
+.I no
 .
 .SH "blacklist section"
 The
@@ -558,6 +567,8 @@ section:
 .B dev_loss_tmo
 .TP
 .B flush_on_last_del
+.TP
+.B retain_attached_hw_handler
 .RE
 .PD
 .LP
