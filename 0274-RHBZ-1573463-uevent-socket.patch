---
 libmultipath/uevent.c |   36 +++++++++++++++++++++++++++---------
 1 file changed, 27 insertions(+), 9 deletions(-)

Index: multipath-tools/libmultipath/uevent.c
===================================================================
--- multipath-tools.orig/libmultipath/uevent.c
+++ multipath-tools/libmultipath/uevent.c
@@ -144,9 +144,16 @@ uevent_dispatch(int (*uev_trigger)(struc
 	}
 }
 
+static void socket_cleanup(void *args)
+{
+	int *sock = (int *)args;
+	if (*sock >= 0)
+		close(*sock);
+}
+
 int uevent_listen(void)
 {
-	int sock;
+	int sock = -1;
 	struct sockaddr_nl snl;
 	struct sockaddr_un sun;
 	socklen_t addrlen;
@@ -154,6 +161,7 @@ int uevent_listen(void)
 	int rcvbufsz = 128*1024;
 	int rcvsz = 0;
 	int rcvszsz = sizeof(rcvsz);
+	int retries = 30;
 	unsigned int *prcvszsz = (unsigned int *)&rcvszsz;
 	const int feature_on = 1;
 
@@ -178,10 +186,14 @@ int uevent_listen(void)
 		condlog(3, "reading events from udev socket.");
 
 		/* the bind takes care of ensuring only one copy running */
-		retval = bind(sock, (struct sockaddr *) &sun, addrlen);
-		if (retval < 0) {
+		while (bind(sock, (struct sockaddr *) &sun, addrlen) < 0 &&
+		       --retries >= 0) {
+			condlog(3, "bind failed, retrying");
+			sleep(1);
+		}
+		if (retries < 0) {
 			condlog(0, "bind failed, exit");
-			goto exit;
+			goto fail;
 		}
 
 		/* enable receiving of the sender credentials */
@@ -227,14 +239,18 @@ int uevent_listen(void)
 		setsockopt(sock, SOL_SOCKET, SO_PASSCRED,
 			   &feature_on, sizeof(feature_on));
 
-		retval = bind(sock, (struct sockaddr *) &snl,
-			      sizeof(struct sockaddr_nl));
-		if (retval < 0) {
+		while(bind(sock, (struct sockaddr *) &snl,
+			   sizeof(struct sockaddr_nl)) < 0 && --retries >= 0) {
+			condlog(3, "bind failed, retrying");
+			sleep(1);
+		}
+		if (retries < 0) {
 			condlog(0, "bind failed, exit");
-			goto exit;
+			goto fail;
 		}
 	}
 
+	pthread_cleanup_push(socket_cleanup, &sock);
 	while (1) {
 		int i;
 		char *pos;
@@ -357,8 +373,10 @@ int uevent_listen(void)
 		pthread_cond_signal(uev_condp);
 		pthread_mutex_unlock(uevc_lockp);
 	}
+	pthread_cleanup_pop(1);
+	return 0;
 
-exit:
+fail:
 	close(sock);
 	return 1;
 }
