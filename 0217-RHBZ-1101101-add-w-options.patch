---
 libmultipath/discovery.c |    3 -
 libmultipath/finder.c    |  137 +++++++++++++++++++++++++++++++++++++++++++++++
 libmultipath/finder.h    |    2 
 libmultipath/vector.h    |    2 
 multipath/main.c         |   53 ++++++++++++++++--
 multipath/multipath.8    |    8 ++
 6 files changed, 199 insertions(+), 6 deletions(-)

Index: multipath-tools/libmultipath/discovery.c
===================================================================
--- multipath-tools.orig/libmultipath/discovery.c
+++ multipath-tools/libmultipath/discovery.c
@@ -45,7 +45,8 @@ store_pathinfo (vector pathvec, vector h
 		condlog(0, "pp->dev too small");
 		goto out;
 	}
-	err = pathinfo(pp, hwtable, flag | DI_BLACKLIST);
+	err = pathinfo(pp, hwtable,
+		       (conf->dry_run == 3)? flag : (flag | DI_BLACKLIST));
 	if (err)
 		goto out;
 
Index: multipath-tools/libmultipath/finder.c
===================================================================
--- multipath-tools.orig/libmultipath/finder.c
+++ multipath-tools/libmultipath/finder.c
@@ -4,6 +4,7 @@
 #include <string.h>
 #include <limits.h>
 #include <stdio.h>
+#include <sys/types.h>
 
 #include "checkers.h"
 #include "vector.h"
@@ -13,6 +14,7 @@
 #include "file.h"
 #include "finder.h"
 #include "defaults.h"
+#include "config.h"
 
 /*
  * Copyright (c) 2010 Benjamin Marzinski, Redhat
@@ -80,6 +82,141 @@ write_out_wwid(int fd, char *wwid) {
 }
 
 int
+do_remove_wwid(int fd, char *str) {
+	char buf[4097];
+	char *ptr;
+	off_t start = 0;
+	int bytes;
+
+	while (1) {
+		if (lseek(fd, start, SEEK_SET) < 0) {
+			condlog(0, "wwid file read lseek failed : %s",
+				strerror(errno));
+			return -1;
+		}
+		bytes = read(fd, buf, 4096);
+		if (bytes < 0) {
+			if (errno == EINTR || errno == EAGAIN)
+				continue;
+			condlog(0, "failed to read from wwids file : %s",
+				strerror(errno));
+			return -1;
+		}
+		if (!bytes) /* didn't find wwid to remove */
+			return 1;
+		buf[bytes] = '\0';
+		ptr = strstr(buf, str);
+		if (ptr != NULL) {
+			condlog(3, "found '%s'", str);
+			if (lseek(fd, start + (ptr - buf), SEEK_SET) < 0) {
+				condlog(0, "write lseek failed : %s",
+					strerror(errno));
+				return -1;
+			}
+			while (1) {
+				if (write(fd, "#", 1) < 0) {
+					if (errno == EINTR || errno == EAGAIN)
+						continue;
+					condlog(0, "failed to write to wwids file : %s", strerror(errno));
+					return -1;
+				}
+				return 0;
+			}
+		}
+		ptr = strrchr(buf, '\n');
+		if (ptr == NULL) { /* shouldn't happen, assume it is EOF */
+			condlog(4, "couldn't find newline, assuming end of file");
+			return 1;
+		}
+		start = start + (ptr - buf) + 1;
+	}
+}
+
+int
+replace_wwids(vector mp)
+{
+	int i, fd, can_write;
+	struct multipath * mpp;
+	size_t len;
+	int ret = -1;
+
+	fd = open_file(DEFAULT_WWIDS_FILE, &can_write, WWIDS_FILE_HEADER);
+	if (fd < 0)
+		goto out;
+	if (!can_write) {
+		condlog(0, "cannot replace wwids. wwids file is read-only");
+		goto out_file;
+	}
+	if (ftruncate(fd, 0) < 0) {
+		condlog(0, "cannot truncate wwids file : %s", strerror(errno));
+		goto out_file;
+	}
+	if (lseek(fd, 0, SEEK_SET) < 0) {
+		condlog(0, "cannot seek to the start of the file : %s",
+			strerror(errno));
+		goto out_file;
+	}
+	len = strlen(WWIDS_FILE_HEADER);
+	if (write_all(fd, WWIDS_FILE_HEADER, len) != len) {
+		condlog(0, "Can't write wwid file header : %s",
+			strerror(errno));
+		/* cleanup partially written header */
+		if (ftruncate(fd, 0) < 0)
+			condlog(0, "Cannot truncate header : %s",
+				strerror(errno));
+		goto out_file;
+	}
+	if (!mp || !mp->allocated) {
+		ret = 0;
+		goto out_file;
+	}
+	vector_foreach_slot(mp, mpp, i) {
+		if (write_out_wwid(fd, mpp->wwid) < 0)
+			goto out_file;
+	}
+	ret = 0;
+out_file:
+	close(fd);
+out:
+	return ret;
+}
+
+
+int
+remove_wwid(char *wwid) {
+	int fd, len, can_write;
+	char *str;
+	int ret = -1;
+
+	len = strlen(wwid) + 4; /* two slashes the newline and a zero byte */
+	str = malloc(len);
+	if (str == NULL) {
+		condlog(0, "can't allocate memory to remove wwid : %s",
+			strerror(errno));
+		return -1;
+	}
+	if (snprintf(str, len, "/%s/\n", wwid) >= len) {
+		condlog(0, "string overflow trying to remove wwid");
+		goto out;
+	}
+	condlog(3, "removing line '%s' from wwids file", str);
+	fd = open_file(DEFAULT_WWIDS_FILE, &can_write, WWIDS_FILE_HEADER);
+	if (fd < 0)
+		goto out;
+	if (!can_write) {
+		condlog(0, "cannot remove wwid. wwids file is read-only");
+		goto out_file;
+	}
+	ret = do_remove_wwid(fd, str);
+
+out_file:
+	close(fd);
+out:
+	free(str);
+	return ret;
+}
+
+int
 check_wwids_file(char *wwid, int write_wwid)
 {
 	int scan_fd, fd, can_write, found, ret;
Index: multipath-tools/libmultipath/finder.h
===================================================================
--- multipath-tools.orig/libmultipath/finder.h
+++ multipath-tools/libmultipath/finder.h
@@ -15,5 +15,7 @@
 int should_multipath(struct path *pp, vector pathvec);
 int remember_wwid(char *wwid);
 int check_wwids_file(char *wwid, int write_wwid);
+int remove_wwid(char *wwid);
+int replace_wwids(vector mp);
 
 #endif /* _FINDER_H */
Index: multipath-tools/libmultipath/vector.h
===================================================================
--- multipath-tools.orig/libmultipath/vector.h
+++ multipath-tools/libmultipath/vector.h
@@ -39,6 +39,8 @@ typedef struct _vector *vector;
 	for (i = 0; (v) && i < (v)->allocated && ((p) = (v)->slot[i]); i++)
 #define vector_foreach_slot_after(v,p,i) \
 	for (; (v) && i < (v)->allocated && ((p) = (v)->slot[i]); i++)
+#define vector_foreach_slot_backwards(v,p,i) \
+	for (i = VECTOR_SIZE(v); i > 0 && ((p) = (v)->slot[i-1]); i--)
 
 /* Prototypes */
 extern vector vector_alloc(void);
Index: multipath-tools/multipath/main.c
===================================================================
--- multipath-tools.orig/multipath/main.c
+++ multipath-tools/multipath/main.c
@@ -83,7 +83,7 @@ usage (char * progname)
 {
 	fprintf (stderr, VERSION_STRING);
 	fprintf (stderr, "Usage:\n");
-	fprintf (stderr, "  %s [-c] [-d] [-r] [-v lvl] [-p pol] [-b fil] [-q] [dev]\n", progname);
+	fprintf (stderr, "  %s [-c|-w|-W] [-d] [-r] [-v lvl] [-p pol] [-b fil] [-q] [dev]\n", progname);
 	fprintf (stderr, "  %s -l|-ll|-f [-v lvl] [-b fil] [dev]\n", progname);
 	fprintf (stderr, "  %s -F [-v lvl]\n", progname);
 	fprintf (stderr, "  %s -h\n", progname);
@@ -100,6 +100,8 @@ usage (char * progname)
 		"  -d      dry run, do not create or update devmaps\n" \
 		"  -r      force devmap reload\n" \
 		"  -p      policy failover|multibus|group_by_serial|group_by_prio\n" \
+		"  -w      remove a device from the wwids file\n" \
+		"  -W      reset the wwids file include only the current devices\n" \
 		"  -b fil  bindings file location\n" \
 		"  -p pol  force all maps to specified path grouping policy :\n" \
 		"          . failover            one path per priority group\n" \
@@ -205,7 +207,6 @@ get_dm_mpvec (vector curmp, vector pathv
 
 		if (!conf->dry_run)
 			reinstate_paths(mpp);
-		remember_wwid(mpp->wwid);
 	}
 	return 0;
 }
@@ -255,7 +256,9 @@ configure (void)
 	/*
 	 * if we have a blacklisted device parameter, exit early
 	 */
-	if (dev && conf->dev_type == DEV_DEVNODE && (filter_devnode(conf->blist_devnode, conf->elist_devnode, dev) > 0)) {
+	if (dev && conf->dev_type == DEV_DEVNODE && conf->dry_run != 3 &&
+	    (filter_devnode(conf->blist_devnode,
+			    conf->elist_devnode, dev) > 0)) {
 		if (conf->dry_run == 2)
 			printf("%s is not a valid multipath device path\n", conf->dev);
 		goto out;
@@ -271,6 +274,17 @@ configure (void)
 			condlog(3, "scope is nul");
 			goto out;
 		}
+		if (conf->dry_run == 3) {
+			r = remove_wwid(refwwid);
+			if (r == 0)
+				printf("wwid '%s' removed\n", refwwid);
+			else if (r == 1) {
+				printf("wwid '%s' not in wwids file\n",
+				       refwwid);
+				r = 0;
+			}
+			goto out;
+		}
 		condlog(3, "scope limited to %s", refwwid);
 		if (conf->dev_type == DEV_DEVNODE ||
 		    conf->dev_type == DEV_DEVT) {
@@ -419,7 +433,7 @@ main (int argc, char *argv[])
 		condlog(0, "multipath tools need sysfs mounted");
 		exit(1);
 	}
-	while ((arg = getopt(argc, argv, ":dchl::FfM:v:p:b:Brqu")) != EOF ) {
+	while ((arg = getopt(argc, argv, ":dchl::FfM:v:p:b:BrquwW")) != EOF ) {
 		switch(arg) {
 		case 1: printf("optarg : %s\n",optarg);
 			break;
@@ -480,6 +494,12 @@ main (int argc, char *argv[])
 			break;
 		case 'u':
 			break;
+		case 'w':
+			conf->dry_run = 3;
+			break;
+		case 'W':
+			conf->dry_run = 4;
+			break;
 		case 'h':
 			usage(argv[0]);
 			exit(0);
@@ -526,6 +546,31 @@ main (int argc, char *argv[])
 		condlog(0, "the -c option requires a path to check");
 		goto out;
 	}
+	if (conf->dry_run == 3 && !conf->dev) {
+		condlog(0, "the -w option requires a device");
+		goto out;
+	}
+	if (conf->dry_run == 4) {
+		struct multipath * mpp;
+		int i;
+		vector curmp;
+
+		curmp = vector_alloc();
+		if (!curmp) {
+			condlog(0, "can't allocate memory for mp list");
+			goto out;
+		}
+		if (dm_get_maps(curmp) == 0)
+			r = replace_wwids(curmp);
+		if (r == 0)
+			printf("successfully reset wwids\n");
+		vector_foreach_slot_backwards(curmp, mpp, i) {
+			vector_del_slot(curmp, i);
+			free_multipath(mpp, KEEP_PATHS);
+		}
+		vector_free(curmp);
+		goto out;
+	}
 	if (conf->remove == FLUSH_ONE) {
 		if (conf->dev_type == DEV_DEVMAP)
 			r = dm_flush_map(conf->dev);
Index: multipath-tools/multipath/multipath.8
===================================================================
--- multipath-tools.orig/multipath/multipath.8
+++ multipath-tools/multipath/multipath.8
@@ -6,7 +6,7 @@ multipath \- Device mapper target autoco
 .RB [\| \-v\ \c
 .IR verbosity \|]
 .RB [\| \-d \|]
-.RB [\| \-h | \-l | \-ll | \-f | \-F | \-B \|]
+.RB [\| \-h | \-l | \-ll | \-f | \-F | \-B | \-w | \-W \|]
 .RB [\| \-p\ \c
 .BR failover | multibus | group_by_serial | group_by_prio | group_by_node_name \|]
 .RB [\| device \|]
@@ -56,6 +56,12 @@ treat the bindings file as read only
 .B \-c
 check if the specified path device is or should be multipathed
 .TP
+.B \-w
+remove the wwid for the specified device from the wwids file
+.TP
+.B \-W
+reset the wwids file to only include the current multipath devices
+.TP
 .BI \-p " policy"
 force maps to specified policy:
 .RS 1.2i
